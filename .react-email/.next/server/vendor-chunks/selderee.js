"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/selderee";
exports.ids = ["vendor-chunks/selderee"];
exports.modules = {

/***/ "(rsc)/./node_modules/selderee/lib/selderee.cjs":
/*!************************************************!*\
  !*** ./node_modules/selderee/lib/selderee.cjs ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar parseley = __webpack_require__(/*! parseley */ \"(rsc)/./node_modules/parseley/lib/parseley.cjs\");\nfunction _interopNamespace(e) {\n    if (e && e.__esModule) return e;\n    var n = Object.create(null);\n    if (e) {\n        Object.keys(e).forEach(function(k) {\n            if (k !== \"default\") {\n                var d = Object.getOwnPropertyDescriptor(e, k);\n                Object.defineProperty(n, k, d.get ? d : {\n                    enumerable: true,\n                    get: function() {\n                        return e[k];\n                    }\n                });\n            }\n        });\n    }\n    n[\"default\"] = e;\n    return Object.freeze(n);\n}\nvar parseley__namespace = /*#__PURE__*/ _interopNamespace(parseley);\nvar Ast = /*#__PURE__*/ Object.freeze({\n    __proto__: null\n});\nvar Types = /*#__PURE__*/ Object.freeze({\n    __proto__: null\n});\nconst treeify = (nodes)=>\"▽\\n\" + treeifyArray(nodes, thinLines);\nconst thinLines = [\n    [\n        \"├─\",\n        \"│ \"\n    ],\n    [\n        \"└─\",\n        \"  \"\n    ]\n];\nconst heavyLines = [\n    [\n        \"┠─\",\n        \"┃ \"\n    ],\n    [\n        \"┖─\",\n        \"  \"\n    ]\n];\nconst doubleLines = [\n    [\n        \"╟─\",\n        \"║ \"\n    ],\n    [\n        \"╙─\",\n        \"  \"\n    ]\n];\nfunction treeifyArray(nodes, tpl = heavyLines) {\n    return prefixItems(tpl, nodes.map((n)=>treeifyNode(n)));\n}\nfunction treeifyNode(node) {\n    switch(node.type){\n        case \"terminal\":\n            {\n                const vctr = node.valueContainer;\n                return `◁ #${vctr.index} ${JSON.stringify(vctr.specificity)} ${vctr.value}`;\n            }\n        case \"tagName\":\n            return `◻ Tag name\\n${treeifyArray(node.variants, doubleLines)}`;\n        case \"attrValue\":\n            return `▣ Attr value: ${node.name}\\n${treeifyArray(node.matchers, doubleLines)}`;\n        case \"attrPresence\":\n            return `◨ Attr presence: ${node.name}\\n${treeifyArray(node.cont)}`;\n        case \"pushElement\":\n            return `◉ Push element: ${node.combinator}\\n${treeifyArray(node.cont, thinLines)}`;\n        case \"popElement\":\n            return `◌ Pop element\\n${treeifyArray(node.cont, thinLines)}`;\n        case \"variant\":\n            return `◇ = ${node.value}\\n${treeifyArray(node.cont)}`;\n        case \"matcher\":\n            return `◈ ${node.matcher} \"${node.value}\"${node.modifier || \"\"}\\n${treeifyArray(node.cont)}`;\n    }\n}\nfunction prefixItems(tpl, items) {\n    return items.map((item, i, { length })=>prefixItem(tpl, item, i === length - 1)).join(\"\\n\");\n}\nfunction prefixItem(tpl, item, tail = true) {\n    const tpl1 = tpl[tail ? 1 : 0];\n    return tpl1[0] + item.split(\"\\n\").join(\"\\n\" + tpl1[1]);\n}\nvar TreeifyBuilder = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    treeify: treeify\n});\nclass DecisionTree {\n    constructor(input){\n        this.branches = weave(toAstTerminalPairs(input));\n    }\n    build(builder) {\n        return builder(this.branches);\n    }\n}\nfunction toAstTerminalPairs(array) {\n    const len = array.length;\n    const results = new Array(len);\n    for(let i = 0; i < len; i++){\n        const [selectorString, val] = array[i];\n        const ast = preprocess(parseley__namespace.parse1(selectorString));\n        results[i] = {\n            ast: ast,\n            terminal: {\n                type: \"terminal\",\n                valueContainer: {\n                    index: i,\n                    value: val,\n                    specificity: ast.specificity\n                }\n            }\n        };\n    }\n    return results;\n}\nfunction preprocess(ast) {\n    reduceSelectorVariants(ast);\n    parseley__namespace.normalize(ast);\n    return ast;\n}\nfunction reduceSelectorVariants(ast) {\n    const newList = [];\n    ast.list.forEach((sel)=>{\n        switch(sel.type){\n            case \"class\":\n                newList.push({\n                    matcher: \"~=\",\n                    modifier: null,\n                    name: \"class\",\n                    namespace: null,\n                    specificity: sel.specificity,\n                    type: \"attrValue\",\n                    value: sel.name\n                });\n                break;\n            case \"id\":\n                newList.push({\n                    matcher: \"=\",\n                    modifier: null,\n                    name: \"id\",\n                    namespace: null,\n                    specificity: sel.specificity,\n                    type: \"attrValue\",\n                    value: sel.name\n                });\n                break;\n            case \"combinator\":\n                reduceSelectorVariants(sel.left);\n                newList.push(sel);\n                break;\n            case \"universal\":\n                break;\n            default:\n                newList.push(sel);\n                break;\n        }\n    });\n    ast.list = newList;\n}\nfunction weave(items) {\n    const branches = [];\n    while(items.length){\n        const topKind = findTopKey(items, (sel)=>true, getSelectorKind);\n        const { matches, nonmatches, empty } = breakByKind(items, topKind);\n        items = nonmatches;\n        if (matches.length) {\n            branches.push(branchOfKind(topKind, matches));\n        }\n        if (empty.length) {\n            branches.push(...terminate(empty));\n        }\n    }\n    return branches;\n}\nfunction terminate(items) {\n    const results = [];\n    for (const item of items){\n        const terminal = item.terminal;\n        if (terminal.type === \"terminal\") {\n            results.push(terminal);\n        } else {\n            const { matches, rest } = partition(terminal.cont, (node)=>node.type === \"terminal\");\n            matches.forEach((node)=>results.push(node));\n            if (rest.length) {\n                terminal.cont = rest;\n                results.push(terminal);\n            }\n        }\n    }\n    return results;\n}\nfunction breakByKind(items, selectedKind) {\n    const matches = [];\n    const nonmatches = [];\n    const empty = [];\n    for (const item of items){\n        const simpsels = item.ast.list;\n        if (simpsels.length) {\n            const isMatch = simpsels.some((node)=>getSelectorKind(node) === selectedKind);\n            (isMatch ? matches : nonmatches).push(item);\n        } else {\n            empty.push(item);\n        }\n    }\n    return {\n        matches,\n        nonmatches,\n        empty\n    };\n}\nfunction getSelectorKind(sel) {\n    switch(sel.type){\n        case \"attrPresence\":\n            return `attrPresence ${sel.name}`;\n        case \"attrValue\":\n            return `attrValue ${sel.name}`;\n        case \"combinator\":\n            return `combinator ${sel.combinator}`;\n        default:\n            return sel.type;\n    }\n}\nfunction branchOfKind(kind, items) {\n    if (kind === \"tag\") {\n        return tagNameBranch(items);\n    }\n    if (kind.startsWith(\"attrValue \")) {\n        return attrValueBranch(kind.substring(10), items);\n    }\n    if (kind.startsWith(\"attrPresence \")) {\n        return attrPresenceBranch(kind.substring(13), items);\n    }\n    if (kind === \"combinator >\") {\n        return combinatorBranch(\">\", items);\n    }\n    if (kind === \"combinator +\") {\n        return combinatorBranch(\"+\", items);\n    }\n    throw new Error(`Unsupported selector kind: ${kind}`);\n}\nfunction tagNameBranch(items) {\n    const groups = spliceAndGroup(items, (x)=>x.type === \"tag\", (x)=>x.name);\n    const variants = Object.entries(groups).map(([name, group])=>({\n            type: \"variant\",\n            value: name,\n            cont: weave(group.items)\n        }));\n    return {\n        type: \"tagName\",\n        variants: variants\n    };\n}\nfunction attrPresenceBranch(name, items) {\n    for (const item of items){\n        spliceSimpleSelector(item, (x)=>x.type === \"attrPresence\" && x.name === name);\n    }\n    return {\n        type: \"attrPresence\",\n        name: name,\n        cont: weave(items)\n    };\n}\nfunction attrValueBranch(name, items) {\n    const groups = spliceAndGroup(items, (x)=>x.type === \"attrValue\" && x.name === name, (x)=>`${x.matcher} ${x.modifier || \"\"} ${x.value}`);\n    const matchers = [];\n    for (const group of Object.values(groups)){\n        const sel = group.oneSimpleSelector;\n        const predicate = getAttrPredicate(sel);\n        const continuation = weave(group.items);\n        matchers.push({\n            type: \"matcher\",\n            matcher: sel.matcher,\n            modifier: sel.modifier,\n            value: sel.value,\n            predicate: predicate,\n            cont: continuation\n        });\n    }\n    return {\n        type: \"attrValue\",\n        name: name,\n        matchers: matchers\n    };\n}\nfunction getAttrPredicate(sel) {\n    if (sel.modifier === \"i\") {\n        const expected = sel.value.toLowerCase();\n        switch(sel.matcher){\n            case \"=\":\n                return (actual)=>expected === actual.toLowerCase();\n            case \"~=\":\n                return (actual)=>actual.toLowerCase().split(/[ \\t]+/).includes(expected);\n            case \"^=\":\n                return (actual)=>actual.toLowerCase().startsWith(expected);\n            case \"$=\":\n                return (actual)=>actual.toLowerCase().endsWith(expected);\n            case \"*=\":\n                return (actual)=>actual.toLowerCase().includes(expected);\n            case \"|=\":\n                return (actual)=>{\n                    const lower = actual.toLowerCase();\n                    return expected === lower || lower.startsWith(expected) && lower[expected.length] === \"-\";\n                };\n        }\n    } else {\n        const expected = sel.value;\n        switch(sel.matcher){\n            case \"=\":\n                return (actual)=>expected === actual;\n            case \"~=\":\n                return (actual)=>actual.split(/[ \\t]+/).includes(expected);\n            case \"^=\":\n                return (actual)=>actual.startsWith(expected);\n            case \"$=\":\n                return (actual)=>actual.endsWith(expected);\n            case \"*=\":\n                return (actual)=>actual.includes(expected);\n            case \"|=\":\n                return (actual)=>expected === actual || actual.startsWith(expected) && actual[expected.length] === \"-\";\n        }\n    }\n}\nfunction combinatorBranch(combinator, items) {\n    const groups = spliceAndGroup(items, (x)=>x.type === \"combinator\" && x.combinator === combinator, (x)=>parseley__namespace.serialize(x.left));\n    const leftItems = [];\n    for (const group of Object.values(groups)){\n        const rightCont = weave(group.items);\n        const leftAst = group.oneSimpleSelector.left;\n        leftItems.push({\n            ast: leftAst,\n            terminal: {\n                type: \"popElement\",\n                cont: rightCont\n            }\n        });\n    }\n    return {\n        type: \"pushElement\",\n        combinator: combinator,\n        cont: weave(leftItems)\n    };\n}\nfunction spliceAndGroup(items, predicate, keyCallback) {\n    const groups = {};\n    while(items.length){\n        const bestKey = findTopKey(items, predicate, keyCallback);\n        const bestKeyPredicate = (sel)=>predicate(sel) && keyCallback(sel) === bestKey;\n        const hasBestKeyPredicate = (item)=>item.ast.list.some(bestKeyPredicate);\n        const { matches, rest } = partition1(items, hasBestKeyPredicate);\n        let oneSimpleSelector = null;\n        for (const item of matches){\n            const splicedNode = spliceSimpleSelector(item, bestKeyPredicate);\n            if (!oneSimpleSelector) {\n                oneSimpleSelector = splicedNode;\n            }\n        }\n        if (oneSimpleSelector == null) {\n            throw new Error(\"No simple selector is found.\");\n        }\n        groups[bestKey] = {\n            oneSimpleSelector: oneSimpleSelector,\n            items: matches\n        };\n        items = rest;\n    }\n    return groups;\n}\nfunction spliceSimpleSelector(item, predicate) {\n    const simpsels = item.ast.list;\n    const matches = new Array(simpsels.length);\n    let firstIndex = -1;\n    for(let i = simpsels.length; i-- > 0;){\n        if (predicate(simpsels[i])) {\n            matches[i] = true;\n            firstIndex = i;\n        }\n    }\n    if (firstIndex == -1) {\n        throw new Error(`Couldn't find the required simple selector.`);\n    }\n    const result = simpsels[firstIndex];\n    item.ast.list = simpsels.filter((sel, i)=>!matches[i]);\n    return result;\n}\nfunction findTopKey(items, predicate, keyCallback) {\n    const candidates = {};\n    for (const item of items){\n        const candidates1 = {};\n        for (const node of item.ast.list.filter(predicate)){\n            candidates1[keyCallback(node)] = true;\n        }\n        for (const key of Object.keys(candidates1)){\n            if (candidates[key]) {\n                candidates[key]++;\n            } else {\n                candidates[key] = 1;\n            }\n        }\n    }\n    let topKind = \"\";\n    let topCounter = 0;\n    for (const entry of Object.entries(candidates)){\n        if (entry[1] > topCounter) {\n            topKind = entry[0];\n            topCounter = entry[1];\n        }\n    }\n    return topKind;\n}\nfunction partition(src, predicate) {\n    const matches = [];\n    const rest = [];\n    for (const x of src){\n        if (predicate(x)) {\n            matches.push(x);\n        } else {\n            rest.push(x);\n        }\n    }\n    return {\n        matches,\n        rest\n    };\n}\nfunction partition1(src, predicate) {\n    const matches = [];\n    const rest = [];\n    for (const x of src){\n        if (predicate(x)) {\n            matches.push(x);\n        } else {\n            rest.push(x);\n        }\n    }\n    return {\n        matches,\n        rest\n    };\n}\nclass Picker {\n    constructor(f){\n        this.f = f;\n    }\n    pickAll(el) {\n        return this.f(el);\n    }\n    pick1(el, preferFirst = false) {\n        const results = this.f(el);\n        const len = results.length;\n        if (len === 0) {\n            return null;\n        }\n        if (len === 1) {\n            return results[0].value;\n        }\n        const comparator = preferFirst ? comparatorPreferFirst : comparatorPreferLast;\n        let result = results[0];\n        for(let i = 1; i < len; i++){\n            const next = results[i];\n            if (comparator(result, next)) {\n                result = next;\n            }\n        }\n        return result.value;\n    }\n}\nfunction comparatorPreferFirst(acc, next) {\n    const diff = parseley.compareSpecificity(next.specificity, acc.specificity);\n    return diff > 0 || diff === 0 && next.index < acc.index;\n}\nfunction comparatorPreferLast(acc, next) {\n    const diff = parseley.compareSpecificity(next.specificity, acc.specificity);\n    return diff > 0 || diff === 0 && next.index > acc.index;\n}\nexports.Ast = Ast;\nexports.DecisionTree = DecisionTree;\nexports.Picker = Picker;\nexports.Treeify = TreeifyBuilder;\nexports.Types = Types;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VsZGVyZWUvbGliL3NlbGRlcmVlLmNqcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUU3RCxJQUFJQyxXQUFXQyxtQkFBT0EsQ0FBQztBQUV2QixTQUFTQyxrQkFBa0JDLENBQUM7SUFDeEIsSUFBSUEsS0FBS0EsRUFBRUMsVUFBVSxFQUFFLE9BQU9EO0lBQzlCLElBQUlFLElBQUlULE9BQU9VLE1BQU0sQ0FBQztJQUN0QixJQUFJSCxHQUFHO1FBQ0hQLE9BQU9XLElBQUksQ0FBQ0osR0FBR0ssT0FBTyxDQUFDLFNBQVVDLENBQUM7WUFDOUIsSUFBSUEsTUFBTSxXQUFXO2dCQUNqQixJQUFJQyxJQUFJZCxPQUFPZSx3QkFBd0IsQ0FBQ1IsR0FBR007Z0JBQzNDYixPQUFPQyxjQUFjLENBQUNRLEdBQUdJLEdBQUdDLEVBQUVFLEdBQUcsR0FBR0YsSUFBSTtvQkFDcENHLFlBQVk7b0JBQ1pELEtBQUs7d0JBQWMsT0FBT1QsQ0FBQyxDQUFDTSxFQUFFO29CQUFFO2dCQUNwQztZQUNKO1FBQ0o7SUFDSjtJQUNBSixDQUFDLENBQUMsVUFBVSxHQUFHRjtJQUNmLE9BQU9QLE9BQU9rQixNQUFNLENBQUNUO0FBQ3pCO0FBRUEsSUFBSVUsc0JBQXNCLFdBQVcsR0FBRWIsa0JBQWtCRjtBQUV6RCxJQUFJZ0IsTUFBTSxXQUFXLEdBQUVwQixPQUFPa0IsTUFBTSxDQUFDO0lBQ2pDRyxXQUFXO0FBQ2Y7QUFFQSxJQUFJQyxRQUFRLFdBQVcsR0FBRXRCLE9BQU9rQixNQUFNLENBQUM7SUFDbkNHLFdBQVc7QUFDZjtBQUVBLE1BQU1FLFVBQVUsQ0FBQ0MsUUFBVSxRQUFRQyxhQUFhRCxPQUFPRTtBQUN2RCxNQUFNQSxZQUFZO0lBQUM7UUFBQztRQUFNO0tBQUs7SUFBRTtRQUFDO1FBQU07S0FBSztDQUFDO0FBQzlDLE1BQU1DLGFBQWE7SUFBQztRQUFDO1FBQU07S0FBSztJQUFF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QUM7UUFDTixJQUFJaEIsU0FBU25FLE9BQU8sQ0FBQyxFQUFFO1FBQ3ZCLElBQUssSUFBSWxCLElBQUksR0FBR0EsSUFBSWlCLEtBQUtqQixJQUFLO1lBQzFCLE1BQU1zRyxPQUFPcEYsT0FBTyxDQUFDbEIsRUFBRTtZQUN2QixJQUFJbUcsV0FBV2QsUUFBUWlCLE9BQU87Z0JBQzFCakIsU0FBU2lCO1lBQ2I7UUFDSjtRQUNBLE9BQU9qQixPQUFPcEksS0FBSztJQUN2QjtBQUNKO0FBQ0EsU0FBU21KLHNCQUFzQkcsR0FBRyxFQUFFRCxJQUFJO0lBQ3BDLE1BQU1FLE9BQU90SixTQUFTdUosa0JBQWtCLENBQUNILEtBQUtoSCxXQUFXLEVBQUVpSCxJQUFJakgsV0FBVztJQUMxRSxPQUFPa0gsT0FBTyxLQUFNQSxTQUFTLEtBQUtGLEtBQUtuSCxLQUFLLEdBQUdvSCxJQUFJcEgsS0FBSztBQUM1RDtBQUNBLFNBQVNrSCxxQkFBcUJFLEdBQUcsRUFBRUQsSUFBSTtJQUNuQyxNQUFNRSxPQUFPdEosU0FBU3VKLGtCQUFrQixDQUFDSCxLQUFLaEgsV0FBVyxFQUFFaUgsSUFBSWpILFdBQVc7SUFDMUUsT0FBT2tILE9BQU8sS0FBTUEsU0FBUyxLQUFLRixLQUFLbkgsS0FBSyxHQUFHb0gsSUFBSXBILEtBQUs7QUFDNUQ7QUFFQW5DLFdBQVcsR0FBR2tCO0FBQ2RsQixvQkFBb0IsR0FBR3dEO0FBQ3ZCeEQsY0FBYyxHQUFHNkk7QUFDakI3SSxlQUFlLEdBQUd1RDtBQUNsQnZELGFBQWEsR0FBR29CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtZW1haWwtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL3NlbGRlcmVlL2xpYi9zZWxkZXJlZS5janM/MjlkNyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBwYXJzZWxleSA9IHJlcXVpcmUoJ3BhcnNlbGV5Jyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wTmFtZXNwYWNlKGUpIHtcbiAgICBpZiAoZSAmJiBlLl9fZXNNb2R1bGUpIHJldHVybiBlO1xuICAgIHZhciBuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBpZiAoZSkge1xuICAgICAgICBPYmplY3Qua2V5cyhlKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICBpZiAoayAhPT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIGspO1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBrLCBkLmdldCA/IGQgOiB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZVtrXTsgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbltcImRlZmF1bHRcIl0gPSBlO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKG4pO1xufVxuXG52YXIgcGFyc2VsZXlfX25hbWVzcGFjZSA9IC8qI19fUFVSRV9fKi9faW50ZXJvcE5hbWVzcGFjZShwYXJzZWxleSk7XG5cbnZhciBBc3QgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsXG59KTtcblxudmFyIFR5cGVzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbFxufSk7XG5cbmNvbnN0IHRyZWVpZnkgPSAobm9kZXMpID0+ICfilr1cXG4nICsgdHJlZWlmeUFycmF5KG5vZGVzLCB0aGluTGluZXMpO1xuY29uc3QgdGhpbkxpbmVzID0gW1sn4pSc4pSAJywgJ+KUgiAnXSwgWyfilJTilIAnLCAnICAnXV07XG5jb25zdCBoZWF2eUxpbmVzID0gW1sn4pSg4pSAJywgJ+KUgyAnXSwgWyfilJbilIAnLCAnICAnXV07XG5jb25zdCBkb3VibGVMaW5lcyA9IFtbJ+KVn+KUgCcsICfilZEgJ10sIFsn4pWZ4pSAJywgJyAgJ11dO1xuZnVuY3Rpb24gdHJlZWlmeUFycmF5KG5vZGVzLCB0cGwgPSBoZWF2eUxpbmVzKSB7XG4gICAgcmV0dXJuIHByZWZpeEl0ZW1zKHRwbCwgbm9kZXMubWFwKG4gPT4gdHJlZWlmeU5vZGUobikpKTtcbn1cbmZ1bmN0aW9uIHRyZWVpZnlOb2RlKG5vZGUpIHtcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgICBjYXNlICd0ZXJtaW5hbCc6IHtcbiAgICAgICAgICAgIGNvbnN0IHZjdHIgPSBub2RlLnZhbHVlQ29udGFpbmVyO1xuICAgICAgICAgICAgcmV0dXJuIGDil4EgIyR7dmN0ci5pbmRleH0gJHtKU09OLnN0cmluZ2lmeSh2Y3RyLnNwZWNpZmljaXR5KX0gJHt2Y3RyLnZhbHVlfWA7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAndGFnTmFtZSc6XG4gICAgICAgICAgICByZXR1cm4gYOKXuyBUYWcgbmFtZVxcbiR7dHJlZWlmeUFycmF5KG5vZGUudmFyaWFudHMsIGRvdWJsZUxpbmVzKX1gO1xuICAgICAgICBjYXNlICdhdHRyVmFsdWUnOlxuICAgICAgICAgICAgcmV0dXJuIGDilqMgQXR0ciB2YWx1ZTogJHtub2RlLm5hbWV9XFxuJHt0cmVlaWZ5QXJyYXkobm9kZS5tYXRjaGVycywgZG91YmxlTGluZXMpfWA7XG4gICAgICAgIGNhc2UgJ2F0dHJQcmVzZW5jZSc6XG4gICAgICAgICAgICByZXR1cm4gYOKXqCBBdHRyIHByZXNlbmNlOiAke25vZGUubmFtZX1cXG4ke3RyZWVpZnlBcnJheShub2RlLmNvbnQpfWA7XG4gICAgICAgIGNhc2UgJ3B1c2hFbGVtZW50JzpcbiAgICAgICAgICAgIHJldHVybiBg4peJIFB1c2ggZWxlbWVudDogJHtub2RlLmNvbWJpbmF0b3J9XFxuJHt0cmVlaWZ5QXJyYXkobm9kZS5jb250LCB0aGluTGluZXMpfWA7XG4gICAgICAgIGNhc2UgJ3BvcEVsZW1lbnQnOlxuICAgICAgICAgICAgcmV0dXJuIGDil4wgUG9wIGVsZW1lbnRcXG4ke3RyZWVpZnlBcnJheShub2RlLmNvbnQsIHRoaW5MaW5lcyl9YDtcbiAgICAgICAgY2FzZSAndmFyaWFudCc6XG4gICAgICAgICAgICByZXR1cm4gYOKXhyA9ICR7bm9kZS52YWx1ZX1cXG4ke3RyZWVpZnlBcnJheShub2RlLmNvbnQpfWA7XG4gICAgICAgIGNhc2UgJ21hdGNoZXInOlxuICAgICAgICAgICAgcmV0dXJuIGDil4ggJHtub2RlLm1hdGNoZXJ9IFwiJHtub2RlLnZhbHVlfVwiJHtub2RlLm1vZGlmaWVyIHx8ICcnfVxcbiR7dHJlZWlmeUFycmF5KG5vZGUuY29udCl9YDtcbiAgICB9XG59XG5mdW5jdGlvbiBwcmVmaXhJdGVtcyh0cGwsIGl0ZW1zKSB7XG4gICAgcmV0dXJuIGl0ZW1zXG4gICAgICAgIC5tYXAoKGl0ZW0sIGksIHsgbGVuZ3RoIH0pID0+IHByZWZpeEl0ZW0odHBsLCBpdGVtLCBpID09PSBsZW5ndGggLSAxKSlcbiAgICAgICAgLmpvaW4oJ1xcbicpO1xufVxuZnVuY3Rpb24gcHJlZml4SXRlbSh0cGwsIGl0ZW0sIHRhaWwgPSB0cnVlKSB7XG4gICAgY29uc3QgdHBsMSA9IHRwbFt0YWlsID8gMSA6IDBdO1xuICAgIHJldHVybiB0cGwxWzBdICsgaXRlbS5zcGxpdCgnXFxuJykuam9pbignXFxuJyArIHRwbDFbMV0pO1xufVxuXG52YXIgVHJlZWlmeUJ1aWxkZXIgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIHRyZWVpZnk6IHRyZWVpZnlcbn0pO1xuXG5jbGFzcyBEZWNpc2lvblRyZWUge1xuICAgIGNvbnN0cnVjdG9yKGlucHV0KSB7XG4gICAgICAgIHRoaXMuYnJhbmNoZXMgPSB3ZWF2ZSh0b0FzdFRlcm1pbmFsUGFpcnMoaW5wdXQpKTtcbiAgICB9XG4gICAgYnVpbGQoYnVpbGRlcikge1xuICAgICAgICByZXR1cm4gYnVpbGRlcih0aGlzLmJyYW5jaGVzKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0b0FzdFRlcm1pbmFsUGFpcnMoYXJyYXkpIHtcbiAgICBjb25zdCBsZW4gPSBhcnJheS5sZW5ndGg7XG4gICAgY29uc3QgcmVzdWx0cyA9IG5ldyBBcnJheShsZW4pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgW3NlbGVjdG9yU3RyaW5nLCB2YWxdID0gYXJyYXlbaV07XG4gICAgICAgIGNvbnN0IGFzdCA9IHByZXByb2Nlc3MocGFyc2VsZXlfX25hbWVzcGFjZS5wYXJzZTEoc2VsZWN0b3JTdHJpbmcpKTtcbiAgICAgICAgcmVzdWx0c1tpXSA9IHtcbiAgICAgICAgICAgIGFzdDogYXN0LFxuICAgICAgICAgICAgdGVybWluYWw6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndGVybWluYWwnLFxuICAgICAgICAgICAgICAgIHZhbHVlQ29udGFpbmVyOiB7IGluZGV4OiBpLCB2YWx1ZTogdmFsLCBzcGVjaWZpY2l0eTogYXN0LnNwZWNpZmljaXR5IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG59XG5mdW5jdGlvbiBwcmVwcm9jZXNzKGFzdCkge1xuICAgIHJlZHVjZVNlbGVjdG9yVmFyaWFudHMoYXN0KTtcbiAgICBwYXJzZWxleV9fbmFtZXNwYWNlLm5vcm1hbGl6ZShhc3QpO1xuICAgIHJldHVybiBhc3Q7XG59XG5mdW5jdGlvbiByZWR1Y2VTZWxlY3RvclZhcmlhbnRzKGFzdCkge1xuICAgIGNvbnN0IG5ld0xpc3QgPSBbXTtcbiAgICBhc3QubGlzdC5mb3JFYWNoKHNlbCA9PiB7XG4gICAgICAgIHN3aXRjaCAoc2VsLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgICAgICAgICBuZXdMaXN0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVyOiAnfj0nLFxuICAgICAgICAgICAgICAgICAgICBtb2RpZmllcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2NsYXNzJyxcbiAgICAgICAgICAgICAgICAgICAgbmFtZXNwYWNlOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBzcGVjaWZpY2l0eTogc2VsLnNwZWNpZmljaXR5LFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYXR0clZhbHVlJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHNlbC5uYW1lLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaWQnOlxuICAgICAgICAgICAgICAgIG5ld0xpc3QucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZXI6ICc9JyxcbiAgICAgICAgICAgICAgICAgICAgbW9kaWZpZXI6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdpZCcsXG4gICAgICAgICAgICAgICAgICAgIG5hbWVzcGFjZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgc3BlY2lmaWNpdHk6IHNlbC5zcGVjaWZpY2l0eSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2F0dHJWYWx1ZScsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBzZWwubmFtZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NvbWJpbmF0b3InOlxuICAgICAgICAgICAgICAgIHJlZHVjZVNlbGVjdG9yVmFyaWFudHMoc2VsLmxlZnQpO1xuICAgICAgICAgICAgICAgIG5ld0xpc3QucHVzaChzZWwpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndW5pdmVyc2FsJzpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgbmV3TGlzdC5wdXNoKHNlbCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBhc3QubGlzdCA9IG5ld0xpc3Q7XG59XG5mdW5jdGlvbiB3ZWF2ZShpdGVtcykge1xuICAgIGNvbnN0IGJyYW5jaGVzID0gW107XG4gICAgd2hpbGUgKGl0ZW1zLmxlbmd0aCkge1xuICAgICAgICBjb25zdCB0b3BLaW5kID0gZmluZFRvcEtleShpdGVtcywgKHNlbCkgPT4gdHJ1ZSwgZ2V0U2VsZWN0b3JLaW5kKTtcbiAgICAgICAgY29uc3QgeyBtYXRjaGVzLCBub25tYXRjaGVzLCBlbXB0eSB9ID0gYnJlYWtCeUtpbmQoaXRlbXMsIHRvcEtpbmQpO1xuICAgICAgICBpdGVtcyA9IG5vbm1hdGNoZXM7XG4gICAgICAgIGlmIChtYXRjaGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgYnJhbmNoZXMucHVzaChicmFuY2hPZktpbmQodG9wS2luZCwgbWF0Y2hlcykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbXB0eS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGJyYW5jaGVzLnB1c2goLi4udGVybWluYXRlKGVtcHR5KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJyYW5jaGVzO1xufVxuZnVuY3Rpb24gdGVybWluYXRlKGl0ZW1zKSB7XG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgICBjb25zdCB0ZXJtaW5hbCA9IGl0ZW0udGVybWluYWw7XG4gICAgICAgIGlmICh0ZXJtaW5hbC50eXBlID09PSAndGVybWluYWwnKSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2godGVybWluYWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgeyBtYXRjaGVzLCByZXN0IH0gPSBwYXJ0aXRpb24odGVybWluYWwuY29udCwgKG5vZGUpID0+IG5vZGUudHlwZSA9PT0gJ3Rlcm1pbmFsJyk7XG4gICAgICAgICAgICBtYXRjaGVzLmZvckVhY2goKG5vZGUpID0+IHJlc3VsdHMucHVzaChub2RlKSk7XG4gICAgICAgICAgICBpZiAocmVzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0ZXJtaW5hbC5jb250ID0gcmVzdDtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godGVybWluYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xufVxuZnVuY3Rpb24gYnJlYWtCeUtpbmQoaXRlbXMsIHNlbGVjdGVkS2luZCkge1xuICAgIGNvbnN0IG1hdGNoZXMgPSBbXTtcbiAgICBjb25zdCBub25tYXRjaGVzID0gW107XG4gICAgY29uc3QgZW1wdHkgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgICAgY29uc3Qgc2ltcHNlbHMgPSBpdGVtLmFzdC5saXN0O1xuICAgICAgICBpZiAoc2ltcHNlbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBpc01hdGNoID0gc2ltcHNlbHMuc29tZShub2RlID0+IGdldFNlbGVjdG9yS2luZChub2RlKSA9PT0gc2VsZWN0ZWRLaW5kKTtcbiAgICAgICAgICAgIChpc01hdGNoID8gbWF0Y2hlcyA6IG5vbm1hdGNoZXMpLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbXB0eS5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IG1hdGNoZXMsIG5vbm1hdGNoZXMsIGVtcHR5IH07XG59XG5mdW5jdGlvbiBnZXRTZWxlY3RvcktpbmQoc2VsKSB7XG4gICAgc3dpdGNoIChzZWwudHlwZSkge1xuICAgICAgICBjYXNlICdhdHRyUHJlc2VuY2UnOlxuICAgICAgICAgICAgcmV0dXJuIGBhdHRyUHJlc2VuY2UgJHtzZWwubmFtZX1gO1xuICAgICAgICBjYXNlICdhdHRyVmFsdWUnOlxuICAgICAgICAgICAgcmV0dXJuIGBhdHRyVmFsdWUgJHtzZWwubmFtZX1gO1xuICAgICAgICBjYXNlICdjb21iaW5hdG9yJzpcbiAgICAgICAgICAgIHJldHVybiBgY29tYmluYXRvciAke3NlbC5jb21iaW5hdG9yfWA7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gc2VsLnR5cGU7XG4gICAgfVxufVxuZnVuY3Rpb24gYnJhbmNoT2ZLaW5kKGtpbmQsIGl0ZW1zKSB7XG4gICAgaWYgKGtpbmQgPT09ICd0YWcnKSB7XG4gICAgICAgIHJldHVybiB0YWdOYW1lQnJhbmNoKGl0ZW1zKTtcbiAgICB9XG4gICAgaWYgKGtpbmQuc3RhcnRzV2l0aCgnYXR0clZhbHVlICcpKSB7XG4gICAgICAgIHJldHVybiBhdHRyVmFsdWVCcmFuY2goa2luZC5zdWJzdHJpbmcoMTApLCBpdGVtcyk7XG4gICAgfVxuICAgIGlmIChraW5kLnN0YXJ0c1dpdGgoJ2F0dHJQcmVzZW5jZSAnKSkge1xuICAgICAgICByZXR1cm4gYXR0clByZXNlbmNlQnJhbmNoKGtpbmQuc3Vic3RyaW5nKDEzKSwgaXRlbXMpO1xuICAgIH1cbiAgICBpZiAoa2luZCA9PT0gJ2NvbWJpbmF0b3IgPicpIHtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmF0b3JCcmFuY2goJz4nLCBpdGVtcyk7XG4gICAgfVxuICAgIGlmIChraW5kID09PSAnY29tYmluYXRvciArJykge1xuICAgICAgICByZXR1cm4gY29tYmluYXRvckJyYW5jaCgnKycsIGl0ZW1zKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBzZWxlY3RvciBraW5kOiAke2tpbmR9YCk7XG59XG5mdW5jdGlvbiB0YWdOYW1lQnJhbmNoKGl0ZW1zKSB7XG4gICAgY29uc3QgZ3JvdXBzID0gc3BsaWNlQW5kR3JvdXAoaXRlbXMsICh4KSA9PiB4LnR5cGUgPT09ICd0YWcnLCAoeCkgPT4geC5uYW1lKTtcbiAgICBjb25zdCB2YXJpYW50cyA9IE9iamVjdC5lbnRyaWVzKGdyb3VwcykubWFwKChbbmFtZSwgZ3JvdXBdKSA9PiAoe1xuICAgICAgICB0eXBlOiAndmFyaWFudCcsXG4gICAgICAgIHZhbHVlOiBuYW1lLFxuICAgICAgICBjb250OiB3ZWF2ZShncm91cC5pdGVtcylcbiAgICB9KSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ3RhZ05hbWUnLFxuICAgICAgICB2YXJpYW50czogdmFyaWFudHNcbiAgICB9O1xufVxuZnVuY3Rpb24gYXR0clByZXNlbmNlQnJhbmNoKG5hbWUsIGl0ZW1zKSB7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICAgIHNwbGljZVNpbXBsZVNlbGVjdG9yKGl0ZW0sICh4KSA9PiAoeC50eXBlID09PSAnYXR0clByZXNlbmNlJykgJiYgKHgubmFtZSA9PT0gbmFtZSkpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnYXR0clByZXNlbmNlJyxcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgY29udDogd2VhdmUoaXRlbXMpXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGF0dHJWYWx1ZUJyYW5jaChuYW1lLCBpdGVtcykge1xuICAgIGNvbnN0IGdyb3VwcyA9IHNwbGljZUFuZEdyb3VwKGl0ZW1zLCAoeCkgPT4gKHgudHlwZSA9PT0gJ2F0dHJWYWx1ZScpICYmICh4Lm5hbWUgPT09IG5hbWUpLCAoeCkgPT4gYCR7eC5tYXRjaGVyfSAke3gubW9kaWZpZXIgfHwgJyd9ICR7eC52YWx1ZX1gKTtcbiAgICBjb25zdCBtYXRjaGVycyA9IFtdO1xuICAgIGZvciAoY29uc3QgZ3JvdXAgb2YgT2JqZWN0LnZhbHVlcyhncm91cHMpKSB7XG4gICAgICAgIGNvbnN0IHNlbCA9IGdyb3VwLm9uZVNpbXBsZVNlbGVjdG9yO1xuICAgICAgICBjb25zdCBwcmVkaWNhdGUgPSBnZXRBdHRyUHJlZGljYXRlKHNlbCk7XG4gICAgICAgIGNvbnN0IGNvbnRpbnVhdGlvbiA9IHdlYXZlKGdyb3VwLml0ZW1zKTtcbiAgICAgICAgbWF0Y2hlcnMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnbWF0Y2hlcicsXG4gICAgICAgICAgICBtYXRjaGVyOiBzZWwubWF0Y2hlcixcbiAgICAgICAgICAgIG1vZGlmaWVyOiBzZWwubW9kaWZpZXIsXG4gICAgICAgICAgICB2YWx1ZTogc2VsLnZhbHVlLFxuICAgICAgICAgICAgcHJlZGljYXRlOiBwcmVkaWNhdGUsXG4gICAgICAgICAgICBjb250OiBjb250aW51YXRpb25cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdhdHRyVmFsdWUnLFxuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICBtYXRjaGVyczogbWF0Y2hlcnNcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0QXR0clByZWRpY2F0ZShzZWwpIHtcbiAgICBpZiAoc2VsLm1vZGlmaWVyID09PSAnaScpIHtcbiAgICAgICAgY29uc3QgZXhwZWN0ZWQgPSBzZWwudmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgc3dpdGNoIChzZWwubWF0Y2hlcikge1xuICAgICAgICAgICAgY2FzZSAnPSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIChhY3R1YWwpID0+IGV4cGVjdGVkID09PSBhY3R1YWwudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGNhc2UgJ349JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gKGFjdHVhbCkgPT4gYWN0dWFsLnRvTG93ZXJDYXNlKCkuc3BsaXQoL1sgXFx0XSsvKS5pbmNsdWRlcyhleHBlY3RlZCk7XG4gICAgICAgICAgICBjYXNlICdePSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIChhY3R1YWwpID0+IGFjdHVhbC50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoZXhwZWN0ZWQpO1xuICAgICAgICAgICAgY2FzZSAnJD0nOlxuICAgICAgICAgICAgICAgIHJldHVybiAoYWN0dWFsKSA9PiBhY3R1YWwudG9Mb3dlckNhc2UoKS5lbmRzV2l0aChleHBlY3RlZCk7XG4gICAgICAgICAgICBjYXNlICcqPSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIChhY3R1YWwpID0+IGFjdHVhbC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKGV4cGVjdGVkKTtcbiAgICAgICAgICAgIGNhc2UgJ3w9JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gKGFjdHVhbCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb3dlciA9IGFjdHVhbC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGV4cGVjdGVkID09PSBsb3dlcikgfHwgKGxvd2VyLnN0YXJ0c1dpdGgoZXhwZWN0ZWQpICYmIGxvd2VyW2V4cGVjdGVkLmxlbmd0aF0gPT09ICctJyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgZXhwZWN0ZWQgPSBzZWwudmFsdWU7XG4gICAgICAgIHN3aXRjaCAoc2VsLm1hdGNoZXIpIHtcbiAgICAgICAgICAgIGNhc2UgJz0nOlxuICAgICAgICAgICAgICAgIHJldHVybiAoYWN0dWFsKSA9PiBleHBlY3RlZCA9PT0gYWN0dWFsO1xuICAgICAgICAgICAgY2FzZSAnfj0nOlxuICAgICAgICAgICAgICAgIHJldHVybiAoYWN0dWFsKSA9PiBhY3R1YWwuc3BsaXQoL1sgXFx0XSsvKS5pbmNsdWRlcyhleHBlY3RlZCk7XG4gICAgICAgICAgICBjYXNlICdePSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIChhY3R1YWwpID0+IGFjdHVhbC5zdGFydHNXaXRoKGV4cGVjdGVkKTtcbiAgICAgICAgICAgIGNhc2UgJyQ9JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gKGFjdHVhbCkgPT4gYWN0dWFsLmVuZHNXaXRoKGV4cGVjdGVkKTtcbiAgICAgICAgICAgIGNhc2UgJyo9JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gKGFjdHVhbCkgPT4gYWN0dWFsLmluY2x1ZGVzKGV4cGVjdGVkKTtcbiAgICAgICAgICAgIGNhc2UgJ3w9JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gKGFjdHVhbCkgPT4gKGV4cGVjdGVkID09PSBhY3R1YWwpIHx8IChhY3R1YWwuc3RhcnRzV2l0aChleHBlY3RlZCkgJiYgYWN0dWFsW2V4cGVjdGVkLmxlbmd0aF0gPT09ICctJyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjb21iaW5hdG9yQnJhbmNoKGNvbWJpbmF0b3IsIGl0ZW1zKSB7XG4gICAgY29uc3QgZ3JvdXBzID0gc3BsaWNlQW5kR3JvdXAoaXRlbXMsICh4KSA9PiAoeC50eXBlID09PSAnY29tYmluYXRvcicpICYmICh4LmNvbWJpbmF0b3IgPT09IGNvbWJpbmF0b3IpLCAoeCkgPT4gcGFyc2VsZXlfX25hbWVzcGFjZS5zZXJpYWxpemUoeC5sZWZ0KSk7XG4gICAgY29uc3QgbGVmdEl0ZW1zID0gW107XG4gICAgZm9yIChjb25zdCBncm91cCBvZiBPYmplY3QudmFsdWVzKGdyb3VwcykpIHtcbiAgICAgICAgY29uc3QgcmlnaHRDb250ID0gd2VhdmUoZ3JvdXAuaXRlbXMpO1xuICAgICAgICBjb25zdCBsZWZ0QXN0ID0gZ3JvdXAub25lU2ltcGxlU2VsZWN0b3IubGVmdDtcbiAgICAgICAgbGVmdEl0ZW1zLnB1c2goe1xuICAgICAgICAgICAgYXN0OiBsZWZ0QXN0LFxuICAgICAgICAgICAgdGVybWluYWw6IHsgdHlwZTogJ3BvcEVsZW1lbnQnLCBjb250OiByaWdodENvbnQgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ3B1c2hFbGVtZW50JyxcbiAgICAgICAgY29tYmluYXRvcjogY29tYmluYXRvcixcbiAgICAgICAgY29udDogd2VhdmUobGVmdEl0ZW1zKVxuICAgIH07XG59XG5mdW5jdGlvbiBzcGxpY2VBbmRHcm91cChpdGVtcywgcHJlZGljYXRlLCBrZXlDYWxsYmFjaykge1xuICAgIGNvbnN0IGdyb3VwcyA9IHt9O1xuICAgIHdoaWxlIChpdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgYmVzdEtleSA9IGZpbmRUb3BLZXkoaXRlbXMsIHByZWRpY2F0ZSwga2V5Q2FsbGJhY2spO1xuICAgICAgICBjb25zdCBiZXN0S2V5UHJlZGljYXRlID0gKHNlbCkgPT4gcHJlZGljYXRlKHNlbCkgJiYga2V5Q2FsbGJhY2soc2VsKSA9PT0gYmVzdEtleTtcbiAgICAgICAgY29uc3QgaGFzQmVzdEtleVByZWRpY2F0ZSA9IChpdGVtKSA9PiBpdGVtLmFzdC5saXN0LnNvbWUoYmVzdEtleVByZWRpY2F0ZSk7XG4gICAgICAgIGNvbnN0IHsgbWF0Y2hlcywgcmVzdCB9ID0gcGFydGl0aW9uMShpdGVtcywgaGFzQmVzdEtleVByZWRpY2F0ZSk7XG4gICAgICAgIGxldCBvbmVTaW1wbGVTZWxlY3RvciA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBtYXRjaGVzKSB7XG4gICAgICAgICAgICBjb25zdCBzcGxpY2VkTm9kZSA9IHNwbGljZVNpbXBsZVNlbGVjdG9yKGl0ZW0sIGJlc3RLZXlQcmVkaWNhdGUpO1xuICAgICAgICAgICAgaWYgKCFvbmVTaW1wbGVTZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIG9uZVNpbXBsZVNlbGVjdG9yID0gc3BsaWNlZE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uZVNpbXBsZVNlbGVjdG9yID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc2ltcGxlIHNlbGVjdG9yIGlzIGZvdW5kLicpO1xuICAgICAgICB9XG4gICAgICAgIGdyb3Vwc1tiZXN0S2V5XSA9IHsgb25lU2ltcGxlU2VsZWN0b3I6IG9uZVNpbXBsZVNlbGVjdG9yLCBpdGVtczogbWF0Y2hlcyB9O1xuICAgICAgICBpdGVtcyA9IHJlc3Q7XG4gICAgfVxuICAgIHJldHVybiBncm91cHM7XG59XG5mdW5jdGlvbiBzcGxpY2VTaW1wbGVTZWxlY3RvcihpdGVtLCBwcmVkaWNhdGUpIHtcbiAgICBjb25zdCBzaW1wc2VscyA9IGl0ZW0uYXN0Lmxpc3Q7XG4gICAgY29uc3QgbWF0Y2hlcyA9IG5ldyBBcnJheShzaW1wc2Vscy5sZW5ndGgpO1xuICAgIGxldCBmaXJzdEluZGV4ID0gLTE7XG4gICAgZm9yIChsZXQgaSA9IHNpbXBzZWxzLmxlbmd0aDsgaS0tID4gMDspIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZShzaW1wc2Vsc1tpXSkpIHtcbiAgICAgICAgICAgIG1hdGNoZXNbaV0gPSB0cnVlO1xuICAgICAgICAgICAgZmlyc3RJbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZpcnN0SW5kZXggPT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZG4ndCBmaW5kIHRoZSByZXF1aXJlZCBzaW1wbGUgc2VsZWN0b3IuYCk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHNpbXBzZWxzW2ZpcnN0SW5kZXhdO1xuICAgIGl0ZW0uYXN0Lmxpc3QgPSBzaW1wc2Vscy5maWx0ZXIoKHNlbCwgaSkgPT4gIW1hdGNoZXNbaV0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBmaW5kVG9wS2V5KGl0ZW1zLCBwcmVkaWNhdGUsIGtleUNhbGxiYWNrKSB7XG4gICAgY29uc3QgY2FuZGlkYXRlcyA9IHt9O1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGVzMSA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgaXRlbS5hc3QubGlzdC5maWx0ZXIocHJlZGljYXRlKSkge1xuICAgICAgICAgICAgY2FuZGlkYXRlczFba2V5Q2FsbGJhY2sobm9kZSldID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhjYW5kaWRhdGVzMSkpIHtcbiAgICAgICAgICAgIGlmIChjYW5kaWRhdGVzW2tleV0pIHtcbiAgICAgICAgICAgICAgICBjYW5kaWRhdGVzW2tleV0rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbmRpZGF0ZXNba2V5XSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHRvcEtpbmQgPSAnJztcbiAgICBsZXQgdG9wQ291bnRlciA9IDA7XG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiBPYmplY3QuZW50cmllcyhjYW5kaWRhdGVzKSkge1xuICAgICAgICBpZiAoZW50cnlbMV0gPiB0b3BDb3VudGVyKSB7XG4gICAgICAgICAgICB0b3BLaW5kID0gZW50cnlbMF07XG4gICAgICAgICAgICB0b3BDb3VudGVyID0gZW50cnlbMV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvcEtpbmQ7XG59XG5mdW5jdGlvbiBwYXJ0aXRpb24oc3JjLCBwcmVkaWNhdGUpIHtcbiAgICBjb25zdCBtYXRjaGVzID0gW107XG4gICAgY29uc3QgcmVzdCA9IFtdO1xuICAgIGZvciAoY29uc3QgeCBvZiBzcmMpIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZSh4KSkge1xuICAgICAgICAgICAgbWF0Y2hlcy5wdXNoKHgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdC5wdXNoKHgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IG1hdGNoZXMsIHJlc3QgfTtcbn1cbmZ1bmN0aW9uIHBhcnRpdGlvbjEoc3JjLCBwcmVkaWNhdGUpIHtcbiAgICBjb25zdCBtYXRjaGVzID0gW107XG4gICAgY29uc3QgcmVzdCA9IFtdO1xuICAgIGZvciAoY29uc3QgeCBvZiBzcmMpIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZSh4KSkge1xuICAgICAgICAgICAgbWF0Y2hlcy5wdXNoKHgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdC5wdXNoKHgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IG1hdGNoZXMsIHJlc3QgfTtcbn1cblxuY2xhc3MgUGlja2VyIHtcbiAgICBjb25zdHJ1Y3RvcihmKSB7XG4gICAgICAgIHRoaXMuZiA9IGY7XG4gICAgfVxuICAgIHBpY2tBbGwoZWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZihlbCk7XG4gICAgfVxuICAgIHBpY2sxKGVsLCBwcmVmZXJGaXJzdCA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSB0aGlzLmYoZWwpO1xuICAgICAgICBjb25zdCBsZW4gPSByZXN1bHRzLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbiA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHNbMF0udmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29tcGFyYXRvciA9IChwcmVmZXJGaXJzdClcbiAgICAgICAgICAgID8gY29tcGFyYXRvclByZWZlckZpcnN0XG4gICAgICAgICAgICA6IGNvbXBhcmF0b3JQcmVmZXJMYXN0O1xuICAgICAgICBsZXQgcmVzdWx0ID0gcmVzdWx0c1swXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY29uc3QgbmV4dCA9IHJlc3VsdHNbaV07XG4gICAgICAgICAgICBpZiAoY29tcGFyYXRvcihyZXN1bHQsIG5leHQpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LnZhbHVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbXBhcmF0b3JQcmVmZXJGaXJzdChhY2MsIG5leHQpIHtcbiAgICBjb25zdCBkaWZmID0gcGFyc2VsZXkuY29tcGFyZVNwZWNpZmljaXR5KG5leHQuc3BlY2lmaWNpdHksIGFjYy5zcGVjaWZpY2l0eSk7XG4gICAgcmV0dXJuIGRpZmYgPiAwIHx8IChkaWZmID09PSAwICYmIG5leHQuaW5kZXggPCBhY2MuaW5kZXgpO1xufVxuZnVuY3Rpb24gY29tcGFyYXRvclByZWZlckxhc3QoYWNjLCBuZXh0KSB7XG4gICAgY29uc3QgZGlmZiA9IHBhcnNlbGV5LmNvbXBhcmVTcGVjaWZpY2l0eShuZXh0LnNwZWNpZmljaXR5LCBhY2Muc3BlY2lmaWNpdHkpO1xuICAgIHJldHVybiBkaWZmID4gMCB8fCAoZGlmZiA9PT0gMCAmJiBuZXh0LmluZGV4ID4gYWNjLmluZGV4KTtcbn1cblxuZXhwb3J0cy5Bc3QgPSBBc3Q7XG5leHBvcnRzLkRlY2lzaW9uVHJlZSA9IERlY2lzaW9uVHJlZTtcbmV4cG9ydHMuUGlja2VyID0gUGlja2VyO1xuZXhwb3J0cy5UcmVlaWZ5ID0gVHJlZWlmeUJ1aWxkZXI7XG5leHBvcnRzLlR5cGVzID0gVHlwZXM7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJwYXJzZWxleSIsInJlcXVpcmUiLCJfaW50ZXJvcE5hbWVzcGFjZSIsImUiLCJfX2VzTW9kdWxlIiwibiIsImNyZWF0ZSIsImtleXMiLCJmb3JFYWNoIiwiayIsImQiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJnZXQiLCJlbnVtZXJhYmxlIiwiZnJlZXplIiwicGFyc2VsZXlfX25hbWVzcGFjZSIsIkFzdCIsIl9fcHJvdG9fXyIsIlR5cGVzIiwidHJlZWlmeSIsIm5vZGVzIiwidHJlZWlmeUFycmF5IiwidGhpbkxpbmVzIiwiaGVhdnlMaW5lcyIsImRvdWJsZUxpbmVzIiwidHBsIiwicHJlZml4SXRlbXMiLCJtYXAiLCJ0cmVlaWZ5Tm9kZSIsIm5vZGUiLCJ0eXBlIiwidmN0ciIsInZhbHVlQ29udGFpbmVyIiwiaW5kZXgiLCJKU09OIiwic3RyaW5naWZ5Iiwic3BlY2lmaWNpdHkiLCJ2YXJpYW50cyIsIm5hbWUiLCJtYXRjaGVycyIsImNvbnQiLCJjb21iaW5hdG9yIiwibWF0Y2hlciIsIm1vZGlmaWVyIiwiaXRlbXMiLCJpdGVtIiwiaSIsImxlbmd0aCIsInByZWZpeEl0ZW0iLCJqb2luIiwidGFpbCIsInRwbDEiLCJzcGxpdCIsIlRyZWVpZnlCdWlsZGVyIiwiRGVjaXNpb25UcmVlIiwiY29uc3RydWN0b3IiLCJpbnB1dCIsImJyYW5jaGVzIiwid2VhdmUiLCJ0b0FzdFRlcm1pbmFsUGFpcnMiLCJidWlsZCIsImJ1aWxkZXIiLCJhcnJheSIsImxlbiIsInJlc3VsdHMiLCJBcnJheSIsInNlbGVjdG9yU3RyaW5nIiwidmFsIiwiYXN0IiwicHJlcHJvY2VzcyIsInBhcnNlMSIsInRlcm1pbmFsIiwicmVkdWNlU2VsZWN0b3JWYXJpYW50cyIsIm5vcm1hbGl6ZSIsIm5ld0xpc3QiLCJsaXN0Iiwic2VsIiwicHVzaCIsIm5hbWVzcGFjZSIsImxlZnQiLCJ0b3BLaW5kIiwiZmluZFRvcEtleSIsImdldFNlbGVjdG9yS2luZCIsIm1hdGNoZXMiLCJub25tYXRjaGVzIiwiZW1wdHkiLCJicmVha0J5S2luZCIsImJyYW5jaE9mS2luZCIsInRlcm1pbmF0ZSIsInJlc3QiLCJwYXJ0aXRpb24iLCJzZWxlY3RlZEtpbmQiLCJzaW1wc2VscyIsImlzTWF0Y2giLCJzb21lIiwia2luZCIsInRhZ05hbWVCcmFuY2giLCJzdGFydHNXaXRoIiwiYXR0clZhbHVlQnJhbmNoIiwic3Vic3RyaW5nIiwiYXR0clByZXNlbmNlQnJhbmNoIiwiY29tYmluYXRvckJyYW5jaCIsIkVycm9yIiwiZ3JvdXBzIiwic3BsaWNlQW5kR3JvdXAiLCJ4IiwiZW50cmllcyIsImdyb3VwIiwic3BsaWNlU2ltcGxlU2VsZWN0b3IiLCJ2YWx1ZXMiLCJvbmVTaW1wbGVTZWxlY3RvciIsInByZWRpY2F0ZSIsImdldEF0dHJQcmVkaWNhdGUiLCJjb250aW51YXRpb24iLCJleHBlY3RlZCIsInRvTG93ZXJDYXNlIiwiYWN0dWFsIiwiaW5jbHVkZXMiLCJlbmRzV2l0aCIsImxvd2VyIiwic2VyaWFsaXplIiwibGVmdEl0ZW1zIiwicmlnaHRDb250IiwibGVmdEFzdCIsImtleUNhbGxiYWNrIiwiYmVzdEtleSIsImJlc3RLZXlQcmVkaWNhdGUiLCJoYXNCZXN0S2V5UHJlZGljYXRlIiwicGFydGl0aW9uMSIsInNwbGljZWROb2RlIiwiZmlyc3RJbmRleCIsInJlc3VsdCIsImZpbHRlciIsImNhbmRpZGF0ZXMiLCJjYW5kaWRhdGVzMSIsImtleSIsInRvcENvdW50ZXIiLCJlbnRyeSIsInNyYyIsIlBpY2tlciIsImYiLCJwaWNrQWxsIiwiZWwiLCJwaWNrMSIsInByZWZlckZpcnN0IiwiY29tcGFyYXRvciIsImNvbXBhcmF0b3JQcmVmZXJGaXJzdCIsImNvbXBhcmF0b3JQcmVmZXJMYXN0IiwibmV4dCIsImFjYyIsImRpZmYiLCJjb21wYXJlU3BlY2lmaWNpdHkiLCJUcmVlaWZ5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/selderee/lib/selderee.cjs\n");

/***/ }),

/***/ "(rsc)/../node_modules/selderee/lib/selderee.cjs":
/*!*************************************************!*\
  !*** ../node_modules/selderee/lib/selderee.cjs ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar parseley = __webpack_require__(/*! parseley */ \"(rsc)/../node_modules/parseley/lib/parseley.cjs\");\nfunction _interopNamespace(e) {\n    if (e && e.__esModule) return e;\n    var n = Object.create(null);\n    if (e) {\n        Object.keys(e).forEach(function(k) {\n            if (k !== \"default\") {\n                var d = Object.getOwnPropertyDescriptor(e, k);\n                Object.defineProperty(n, k, d.get ? d : {\n                    enumerable: true,\n                    get: function() {\n                        return e[k];\n                    }\n                });\n            }\n        });\n    }\n    n[\"default\"] = e;\n    return Object.freeze(n);\n}\nvar parseley__namespace = /*#__PURE__*/ _interopNamespace(parseley);\nvar Ast = /*#__PURE__*/ Object.freeze({\n    __proto__: null\n});\nvar Types = /*#__PURE__*/ Object.freeze({\n    __proto__: null\n});\nconst treeify = (nodes)=>\"▽\\n\" + treeifyArray(nodes, thinLines);\nconst thinLines = [\n    [\n        \"├─\",\n        \"│ \"\n    ],\n    [\n        \"└─\",\n        \"  \"\n    ]\n];\nconst heavyLines = [\n    [\n        \"┠─\",\n        \"┃ \"\n    ],\n    [\n        \"┖─\",\n        \"  \"\n    ]\n];\nconst doubleLines = [\n    [\n        \"╟─\",\n        \"║ \"\n    ],\n    [\n        \"╙─\",\n        \"  \"\n    ]\n];\nfunction treeifyArray(nodes, tpl = heavyLines) {\n    return prefixItems(tpl, nodes.map((n)=>treeifyNode(n)));\n}\nfunction treeifyNode(node) {\n    switch(node.type){\n        case \"terminal\":\n            {\n                const vctr = node.valueContainer;\n                return `◁ #${vctr.index} ${JSON.stringify(vctr.specificity)} ${vctr.value}`;\n            }\n        case \"tagName\":\n            return `◻ Tag name\\n${treeifyArray(node.variants, doubleLines)}`;\n        case \"attrValue\":\n            return `▣ Attr value: ${node.name}\\n${treeifyArray(node.matchers, doubleLines)}`;\n        case \"attrPresence\":\n            return `◨ Attr presence: ${node.name}\\n${treeifyArray(node.cont)}`;\n        case \"pushElement\":\n            return `◉ Push element: ${node.combinator}\\n${treeifyArray(node.cont, thinLines)}`;\n        case \"popElement\":\n            return `◌ Pop element\\n${treeifyArray(node.cont, thinLines)}`;\n        case \"variant\":\n            return `◇ = ${node.value}\\n${treeifyArray(node.cont)}`;\n        case \"matcher\":\n            return `◈ ${node.matcher} \"${node.value}\"${node.modifier || \"\"}\\n${treeifyArray(node.cont)}`;\n    }\n}\nfunction prefixItems(tpl, items) {\n    return items.map((item, i, { length })=>prefixItem(tpl, item, i === length - 1)).join(\"\\n\");\n}\nfunction prefixItem(tpl, item, tail = true) {\n    const tpl1 = tpl[tail ? 1 : 0];\n    return tpl1[0] + item.split(\"\\n\").join(\"\\n\" + tpl1[1]);\n}\nvar TreeifyBuilder = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    treeify: treeify\n});\nclass DecisionTree {\n    constructor(input){\n        this.branches = weave(toAstTerminalPairs(input));\n    }\n    build(builder) {\n        return builder(this.branches);\n    }\n}\nfunction toAstTerminalPairs(array) {\n    const len = array.length;\n    const results = new Array(len);\n    for(let i = 0; i < len; i++){\n        const [selectorString, val] = array[i];\n        const ast = preprocess(parseley__namespace.parse1(selectorString));\n        results[i] = {\n            ast: ast,\n            terminal: {\n                type: \"terminal\",\n                valueContainer: {\n                    index: i,\n                    value: val,\n                    specificity: ast.specificity\n                }\n            }\n        };\n    }\n    return results;\n}\nfunction preprocess(ast) {\n    reduceSelectorVariants(ast);\n    parseley__namespace.normalize(ast);\n    return ast;\n}\nfunction reduceSelectorVariants(ast) {\n    const newList = [];\n    ast.list.forEach((sel)=>{\n        switch(sel.type){\n            case \"class\":\n                newList.push({\n                    matcher: \"~=\",\n                    modifier: null,\n                    name: \"class\",\n                    namespace: null,\n                    specificity: sel.specificity,\n                    type: \"attrValue\",\n                    value: sel.name\n                });\n                break;\n            case \"id\":\n                newList.push({\n                    matcher: \"=\",\n                    modifier: null,\n                    name: \"id\",\n                    namespace: null,\n                    specificity: sel.specificity,\n                    type: \"attrValue\",\n                    value: sel.name\n                });\n                break;\n            case \"combinator\":\n                reduceSelectorVariants(sel.left);\n                newList.push(sel);\n                break;\n            case \"universal\":\n                break;\n            default:\n                newList.push(sel);\n                break;\n        }\n    });\n    ast.list = newList;\n}\nfunction weave(items) {\n    const branches = [];\n    while(items.length){\n        const topKind = findTopKey(items, (sel)=>true, getSelectorKind);\n        const { matches, nonmatches, empty } = breakByKind(items, topKind);\n        items = nonmatches;\n        if (matches.length) {\n            branches.push(branchOfKind(topKind, matches));\n        }\n        if (empty.length) {\n            branches.push(...terminate(empty));\n        }\n    }\n    return branches;\n}\nfunction terminate(items) {\n    const results = [];\n    for (const item of items){\n        const terminal = item.terminal;\n        if (terminal.type === \"terminal\") {\n            results.push(terminal);\n        } else {\n            const { matches, rest } = partition(terminal.cont, (node)=>node.type === \"terminal\");\n            matches.forEach((node)=>results.push(node));\n            if (rest.length) {\n                terminal.cont = rest;\n                results.push(terminal);\n            }\n        }\n    }\n    return results;\n}\nfunction breakByKind(items, selectedKind) {\n    const matches = [];\n    const nonmatches = [];\n    const empty = [];\n    for (const item of items){\n        const simpsels = item.ast.list;\n        if (simpsels.length) {\n            const isMatch = simpsels.some((node)=>getSelectorKind(node) === selectedKind);\n            (isMatch ? matches : nonmatches).push(item);\n        } else {\n            empty.push(item);\n        }\n    }\n    return {\n        matches,\n        nonmatches,\n        empty\n    };\n}\nfunction getSelectorKind(sel) {\n    switch(sel.type){\n        case \"attrPresence\":\n            return `attrPresence ${sel.name}`;\n        case \"attrValue\":\n            return `attrValue ${sel.name}`;\n        case \"combinator\":\n            return `combinator ${sel.combinator}`;\n        default:\n            return sel.type;\n    }\n}\nfunction branchOfKind(kind, items) {\n    if (kind === \"tag\") {\n        return tagNameBranch(items);\n    }\n    if (kind.startsWith(\"attrValue \")) {\n        return attrValueBranch(kind.substring(10), items);\n    }\n    if (kind.startsWith(\"attrPresence \")) {\n        return attrPresenceBranch(kind.substring(13), items);\n    }\n    if (kind === \"combinator >\") {\n        return combinatorBranch(\">\", items);\n    }\n    if (kind === \"combinator +\") {\n        return combinatorBranch(\"+\", items);\n    }\n    throw new Error(`Unsupported selector kind: ${kind}`);\n}\nfunction tagNameBranch(items) {\n    const groups = spliceAndGroup(items, (x)=>x.type === \"tag\", (x)=>x.name);\n    const variants = Object.entries(groups).map(([name, group])=>({\n            type: \"variant\",\n            value: name,\n            cont: weave(group.items)\n        }));\n    return {\n        type: \"tagName\",\n        variants: variants\n    };\n}\nfunction attrPresenceBranch(name, items) {\n    for (const item of items){\n        spliceSimpleSelector(item, (x)=>x.type === \"attrPresence\" && x.name === name);\n    }\n    return {\n        type: \"attrPresence\",\n        name: name,\n        cont: weave(items)\n    };\n}\nfunction attrValueBranch(name, items) {\n    const groups = spliceAndGroup(items, (x)=>x.type === \"attrValue\" && x.name === name, (x)=>`${x.matcher} ${x.modifier || \"\"} ${x.value}`);\n    const matchers = [];\n    for (const group of Object.values(groups)){\n        const sel = group.oneSimpleSelector;\n        const predicate = getAttrPredicate(sel);\n        const continuation = weave(group.items);\n        matchers.push({\n            type: \"matcher\",\n            matcher: sel.matcher,\n            modifier: sel.modifier,\n            value: sel.value,\n            predicate: predicate,\n            cont: continuation\n        });\n    }\n    return {\n        type: \"attrValue\",\n        name: name,\n        matchers: matchers\n    };\n}\nfunction getAttrPredicate(sel) {\n    if (sel.modifier === \"i\") {\n        const expected = sel.value.toLowerCase();\n        switch(sel.matcher){\n            case \"=\":\n                return (actual)=>expected === actual.toLowerCase();\n            case \"~=\":\n                return (actual)=>actual.toLowerCase().split(/[ \\t]+/).includes(expected);\n            case \"^=\":\n                return (actual)=>actual.toLowerCase().startsWith(expected);\n            case \"$=\":\n                return (actual)=>actual.toLowerCase().endsWith(expected);\n            case \"*=\":\n                return (actual)=>actual.toLowerCase().includes(expected);\n            case \"|=\":\n                return (actual)=>{\n                    const lower = actual.toLowerCase();\n                    return expected === lower || lower.startsWith(expected) && lower[expected.length] === \"-\";\n                };\n        }\n    } else {\n        const expected = sel.value;\n        switch(sel.matcher){\n            case \"=\":\n                return (actual)=>expected === actual;\n            case \"~=\":\n                return (actual)=>actual.split(/[ \\t]+/).includes(expected);\n            case \"^=\":\n                return (actual)=>actual.startsWith(expected);\n            case \"$=\":\n                return (actual)=>actual.endsWith(expected);\n            case \"*=\":\n                return (actual)=>actual.includes(expected);\n            case \"|=\":\n                return (actual)=>expected === actual || actual.startsWith(expected) && actual[expected.length] === \"-\";\n        }\n    }\n}\nfunction combinatorBranch(combinator, items) {\n    const groups = spliceAndGroup(items, (x)=>x.type === \"combinator\" && x.combinator === combinator, (x)=>parseley__namespace.serialize(x.left));\n    const leftItems = [];\n    for (const group of Object.values(groups)){\n        const rightCont = weave(group.items);\n        const leftAst = group.oneSimpleSelector.left;\n        leftItems.push({\n            ast: leftAst,\n            terminal: {\n                type: \"popElement\",\n                cont: rightCont\n            }\n        });\n    }\n    return {\n        type: \"pushElement\",\n        combinator: combinator,\n        cont: weave(leftItems)\n    };\n}\nfunction spliceAndGroup(items, predicate, keyCallback) {\n    const groups = {};\n    while(items.length){\n        const bestKey = findTopKey(items, predicate, keyCallback);\n        const bestKeyPredicate = (sel)=>predicate(sel) && keyCallback(sel) === bestKey;\n        const hasBestKeyPredicate = (item)=>item.ast.list.some(bestKeyPredicate);\n        const { matches, rest } = partition1(items, hasBestKeyPredicate);\n        let oneSimpleSelector = null;\n        for (const item of matches){\n            const splicedNode = spliceSimpleSelector(item, bestKeyPredicate);\n            if (!oneSimpleSelector) {\n                oneSimpleSelector = splicedNode;\n            }\n        }\n        if (oneSimpleSelector == null) {\n            throw new Error(\"No simple selector is found.\");\n        }\n        groups[bestKey] = {\n            oneSimpleSelector: oneSimpleSelector,\n            items: matches\n        };\n        items = rest;\n    }\n    return groups;\n}\nfunction spliceSimpleSelector(item, predicate) {\n    const simpsels = item.ast.list;\n    const matches = new Array(simpsels.length);\n    let firstIndex = -1;\n    for(let i = simpsels.length; i-- > 0;){\n        if (predicate(simpsels[i])) {\n            matches[i] = true;\n            firstIndex = i;\n        }\n    }\n    if (firstIndex == -1) {\n        throw new Error(`Couldn't find the required simple selector.`);\n    }\n    const result = simpsels[firstIndex];\n    item.ast.list = simpsels.filter((sel, i)=>!matches[i]);\n    return result;\n}\nfunction findTopKey(items, predicate, keyCallback) {\n    const candidates = {};\n    for (const item of items){\n        const candidates1 = {};\n        for (const node of item.ast.list.filter(predicate)){\n            candidates1[keyCallback(node)] = true;\n        }\n        for (const key of Object.keys(candidates1)){\n            if (candidates[key]) {\n                candidates[key]++;\n            } else {\n                candidates[key] = 1;\n            }\n        }\n    }\n    let topKind = \"\";\n    let topCounter = 0;\n    for (const entry of Object.entries(candidates)){\n        if (entry[1] > topCounter) {\n            topKind = entry[0];\n            topCounter = entry[1];\n        }\n    }\n    return topKind;\n}\nfunction partition(src, predicate) {\n    const matches = [];\n    const rest = [];\n    for (const x of src){\n        if (predicate(x)) {\n            matches.push(x);\n        } else {\n            rest.push(x);\n        }\n    }\n    return {\n        matches,\n        rest\n    };\n}\nfunction partition1(src, predicate) {\n    const matches = [];\n    const rest = [];\n    for (const x of src){\n        if (predicate(x)) {\n            matches.push(x);\n        } else {\n            rest.push(x);\n        }\n    }\n    return {\n        matches,\n        rest\n    };\n}\nclass Picker {\n    constructor(f){\n        this.f = f;\n    }\n    pickAll(el) {\n        return this.f(el);\n    }\n    pick1(el, preferFirst = false) {\n        const results = this.f(el);\n        const len = results.length;\n        if (len === 0) {\n            return null;\n        }\n        if (len === 1) {\n            return results[0].value;\n        }\n        const comparator = preferFirst ? comparatorPreferFirst : comparatorPreferLast;\n        let result = results[0];\n        for(let i = 1; i < len; i++){\n            const next = results[i];\n            if (comparator(result, next)) {\n                result = next;\n            }\n        }\n        return result.value;\n    }\n}\nfunction comparatorPreferFirst(acc, next) {\n    const diff = parseley.compareSpecificity(next.specificity, acc.specificity);\n    return diff > 0 || diff === 0 && next.index < acc.index;\n}\nfunction comparatorPreferLast(acc, next) {\n    const diff = parseley.compareSpecificity(next.specificity, acc.specificity);\n    return diff > 0 || diff === 0 && next.index > acc.index;\n}\nexports.Ast = Ast;\nexports.DecisionTree = DecisionTree;\nexports.Picker = Picker;\nexports.Treeify = TreeifyBuilder;\nexports.Types = Types;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL3NlbGRlcmVlL2xpYi9zZWxkZXJlZS5janMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQUEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFFN0QsSUFBSUMsV0FBV0MsbUJBQU9BLENBQUM7QUFFdkIsU0FBU0Msa0JBQWtCQyxDQUFDO0lBQ3hCLElBQUlBLEtBQUtBLEVBQUVDLFVBQVUsRUFBRSxPQUFPRDtJQUM5QixJQUFJRSxJQUFJVCxPQUFPVSxNQUFNLENBQUM7SUFDdEIsSUFBSUgsR0FBRztRQUNIUCxPQUFPVyxJQUFJLENBQUNKLEdBQUdLLE9BQU8sQ0FBQyxTQUFVQyxDQUFDO1lBQzlCLElBQUlBLE1BQU0sV0FBVztnQkFDakIsSUFBSUMsSUFBSWQsT0FBT2Usd0JBQXdCLENBQUNSLEdBQUdNO2dCQUMzQ2IsT0FBT0MsY0FBYyxDQUFDUSxHQUFHSSxHQUFHQyxFQUFFRSxHQUFHLEdBQUdGLElBQUk7b0JBQ3BDRyxZQUFZO29CQUNaRCxLQUFLO3dCQUFjLE9BQU9ULENBQUMsQ0FBQ00sRUFBRTtvQkFBRTtnQkFDcEM7WUFDSjtRQUNKO0lBQ0o7SUFDQUosQ0FBQyxDQUFDLFVBQVUsR0FBR0Y7SUFDZixPQUFPUCxPQUFPa0IsTUFBTSxDQUFDVDtBQUN6QjtBQUVBLElBQUlVLHNCQUFzQixXQUFXLEdBQUViLGtCQUFrQkY7QUFFekQsSUFBSWdCLE1BQU0sV0FBVyxHQUFFcEIsT0FBT2tCLE1BQU0sQ0FBQztJQUNqQ0csV0FBVztBQUNmO0FBRUEsSUFBSUMsUUFBUSxXQUFXLEdBQUV0QixPQUFPa0IsTUFBTSxDQUFDO0lBQ25DRyxXQUFXO0FBQ2Y7QUFFQSxNQUFNRSxVQUFVLENBQUNDLFFBQVUsUUFBUUMsYUFBYUQsT0FBT0U7QUFDdkQsTUFBTUEsWUFBWTtJQUFDO1FBQUM7UUFBTTtLQUFLO0lBQUU7UUFBQztRQUFNO0tBQUs7Q0FBQztBQUM5QyxNQUFNQyxhQUFhO0lBQUM7UUFBQztRQUFNO0tBQUs7SUFB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Q0FDO1FBQ04sSUFBSWhCLFNBQVNuRSxPQUFPLENBQUMsRUFBRTtRQUN2QixJQUFLLElBQUlsQixJQUFJLEdBQUdBLElBQUlpQixLQUFLakIsSUFBSztZQUMxQixNQUFNc0csT0FBT3BGLE9BQU8sQ0FBQ2xCLEVBQUU7WUFDdkIsSUFBSW1HLFdBQVdkLFFBQVFpQixPQUFPO2dCQUMxQmpCLFNBQVNpQjtZQUNiO1FBQ0o7UUFDQSxPQUFPakIsT0FBT3BJLEtBQUs7SUFDdkI7QUFDSjtBQUNBLFNBQVNtSixzQkFBc0JHLEdBQUcsRUFBRUQsSUFBSTtJQUNwQyxNQUFNRSxPQUFPdEosU0FBU3VKLGtCQUFrQixDQUFDSCxLQUFLaEgsV0FBVyxFQUFFaUgsSUFBSWpILFdBQVc7SUFDMUUsT0FBT2tILE9BQU8sS0FBTUEsU0FBUyxLQUFLRixLQUFLbkgsS0FBSyxHQUFHb0gsSUFBSXBILEtBQUs7QUFDNUQ7QUFDQSxTQUFTa0gscUJBQXFCRSxHQUFHLEVBQUVELElBQUk7SUFDbkMsTUFBTUUsT0FBT3RKLFNBQVN1SixrQkFBa0IsQ0FBQ0gsS0FBS2hILFdBQVcsRUFBRWlILElBQUlqSCxXQUFXO0lBQzFFLE9BQU9rSCxPQUFPLEtBQU1BLFNBQVMsS0FBS0YsS0FBS25ILEtBQUssR0FBR29ILElBQUlwSCxLQUFLO0FBQzVEO0FBRUFuQyxXQUFXLEdBQUdrQjtBQUNkbEIsb0JBQW9CLEdBQUd3RDtBQUN2QnhELGNBQWMsR0FBRzZJO0FBQ2pCN0ksZUFBZSxHQUFHdUQ7QUFDbEJ2RCxhQUFhLEdBQUdvQiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWVtYWlsLWNsaWVudC8uLi9ub2RlX21vZHVsZXMvc2VsZGVyZWUvbGliL3NlbGRlcmVlLmNqcz8zZmIwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIHBhcnNlbGV5ID0gcmVxdWlyZSgncGFyc2VsZXknKTtcblxuZnVuY3Rpb24gX2ludGVyb3BOYW1lc3BhY2UoZSkge1xuICAgIGlmIChlICYmIGUuX19lc01vZHVsZSkgcmV0dXJuIGU7XG4gICAgdmFyIG4gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGlmIChlKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKGUpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIGlmIChrICE9PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgICAgICAgICB2YXIgZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgayk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIGssIGQuZ2V0ID8gZCA6IHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlW2tdOyB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBuW1wiZGVmYXVsdFwiXSA9IGU7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUobik7XG59XG5cbnZhciBwYXJzZWxleV9fbmFtZXNwYWNlID0gLyojX19QVVJFX18qL19pbnRlcm9wTmFtZXNwYWNlKHBhcnNlbGV5KTtcblxudmFyIEFzdCA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGxcbn0pO1xuXG52YXIgVHlwZXMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsXG59KTtcblxuY29uc3QgdHJlZWlmeSA9IChub2RlcykgPT4gJ+KWvVxcbicgKyB0cmVlaWZ5QXJyYXkobm9kZXMsIHRoaW5MaW5lcyk7XG5jb25zdCB0aGluTGluZXMgPSBbWyfilJzilIAnLCAn4pSCICddLCBbJ+KUlOKUgCcsICcgICddXTtcbmNvbnN0IGhlYXZ5TGluZXMgPSBbWyfilKDilIAnLCAn4pSDICddLCBbJ+KUluKUgCcsICcgICddXTtcbmNvbnN0IGRvdWJsZUxpbmVzID0gW1sn4pWf4pSAJywgJ+KVkSAnXSwgWyfilZnilIAnLCAnICAnXV07XG5mdW5jdGlvbiB0cmVlaWZ5QXJyYXkobm9kZXMsIHRwbCA9IGhlYXZ5TGluZXMpIHtcbiAgICByZXR1cm4gcHJlZml4SXRlbXModHBsLCBub2Rlcy5tYXAobiA9PiB0cmVlaWZ5Tm9kZShuKSkpO1xufVxuZnVuY3Rpb24gdHJlZWlmeU5vZGUobm9kZSkge1xuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgIGNhc2UgJ3Rlcm1pbmFsJzoge1xuICAgICAgICAgICAgY29uc3QgdmN0ciA9IG5vZGUudmFsdWVDb250YWluZXI7XG4gICAgICAgICAgICByZXR1cm4gYOKXgSAjJHt2Y3RyLmluZGV4fSAke0pTT04uc3RyaW5naWZ5KHZjdHIuc3BlY2lmaWNpdHkpfSAke3ZjdHIudmFsdWV9YDtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICd0YWdOYW1lJzpcbiAgICAgICAgICAgIHJldHVybiBg4pe7IFRhZyBuYW1lXFxuJHt0cmVlaWZ5QXJyYXkobm9kZS52YXJpYW50cywgZG91YmxlTGluZXMpfWA7XG4gICAgICAgIGNhc2UgJ2F0dHJWYWx1ZSc6XG4gICAgICAgICAgICByZXR1cm4gYOKWoyBBdHRyIHZhbHVlOiAke25vZGUubmFtZX1cXG4ke3RyZWVpZnlBcnJheShub2RlLm1hdGNoZXJzLCBkb3VibGVMaW5lcyl9YDtcbiAgICAgICAgY2FzZSAnYXR0clByZXNlbmNlJzpcbiAgICAgICAgICAgIHJldHVybiBg4peoIEF0dHIgcHJlc2VuY2U6ICR7bm9kZS5uYW1lfVxcbiR7dHJlZWlmeUFycmF5KG5vZGUuY29udCl9YDtcbiAgICAgICAgY2FzZSAncHVzaEVsZW1lbnQnOlxuICAgICAgICAgICAgcmV0dXJuIGDil4kgUHVzaCBlbGVtZW50OiAke25vZGUuY29tYmluYXRvcn1cXG4ke3RyZWVpZnlBcnJheShub2RlLmNvbnQsIHRoaW5MaW5lcyl9YDtcbiAgICAgICAgY2FzZSAncG9wRWxlbWVudCc6XG4gICAgICAgICAgICByZXR1cm4gYOKXjCBQb3AgZWxlbWVudFxcbiR7dHJlZWlmeUFycmF5KG5vZGUuY29udCwgdGhpbkxpbmVzKX1gO1xuICAgICAgICBjYXNlICd2YXJpYW50JzpcbiAgICAgICAgICAgIHJldHVybiBg4peHID0gJHtub2RlLnZhbHVlfVxcbiR7dHJlZWlmeUFycmF5KG5vZGUuY29udCl9YDtcbiAgICAgICAgY2FzZSAnbWF0Y2hlcic6XG4gICAgICAgICAgICByZXR1cm4gYOKXiCAke25vZGUubWF0Y2hlcn0gXCIke25vZGUudmFsdWV9XCIke25vZGUubW9kaWZpZXIgfHwgJyd9XFxuJHt0cmVlaWZ5QXJyYXkobm9kZS5jb250KX1gO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHByZWZpeEl0ZW1zKHRwbCwgaXRlbXMpIHtcbiAgICByZXR1cm4gaXRlbXNcbiAgICAgICAgLm1hcCgoaXRlbSwgaSwgeyBsZW5ndGggfSkgPT4gcHJlZml4SXRlbSh0cGwsIGl0ZW0sIGkgPT09IGxlbmd0aCAtIDEpKVxuICAgICAgICAuam9pbignXFxuJyk7XG59XG5mdW5jdGlvbiBwcmVmaXhJdGVtKHRwbCwgaXRlbSwgdGFpbCA9IHRydWUpIHtcbiAgICBjb25zdCB0cGwxID0gdHBsW3RhaWwgPyAxIDogMF07XG4gICAgcmV0dXJuIHRwbDFbMF0gKyBpdGVtLnNwbGl0KCdcXG4nKS5qb2luKCdcXG4nICsgdHBsMVsxXSk7XG59XG5cbnZhciBUcmVlaWZ5QnVpbGRlciA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgdHJlZWlmeTogdHJlZWlmeVxufSk7XG5cbmNsYXNzIERlY2lzaW9uVHJlZSB7XG4gICAgY29uc3RydWN0b3IoaW5wdXQpIHtcbiAgICAgICAgdGhpcy5icmFuY2hlcyA9IHdlYXZlKHRvQXN0VGVybWluYWxQYWlycyhpbnB1dCkpO1xuICAgIH1cbiAgICBidWlsZChidWlsZGVyKSB7XG4gICAgICAgIHJldHVybiBidWlsZGVyKHRoaXMuYnJhbmNoZXMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRvQXN0VGVybWluYWxQYWlycyhhcnJheSkge1xuICAgIGNvbnN0IGxlbiA9IGFycmF5Lmxlbmd0aDtcbiAgICBjb25zdCByZXN1bHRzID0gbmV3IEFycmF5KGxlbik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjb25zdCBbc2VsZWN0b3JTdHJpbmcsIHZhbF0gPSBhcnJheVtpXTtcbiAgICAgICAgY29uc3QgYXN0ID0gcHJlcHJvY2VzcyhwYXJzZWxleV9fbmFtZXNwYWNlLnBhcnNlMShzZWxlY3RvclN0cmluZykpO1xuICAgICAgICByZXN1bHRzW2ldID0ge1xuICAgICAgICAgICAgYXN0OiBhc3QsXG4gICAgICAgICAgICB0ZXJtaW5hbDoge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd0ZXJtaW5hbCcsXG4gICAgICAgICAgICAgICAgdmFsdWVDb250YWluZXI6IHsgaW5kZXg6IGksIHZhbHVlOiB2YWwsIHNwZWNpZmljaXR5OiBhc3Quc3BlY2lmaWNpdHkgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbn1cbmZ1bmN0aW9uIHByZXByb2Nlc3MoYXN0KSB7XG4gICAgcmVkdWNlU2VsZWN0b3JWYXJpYW50cyhhc3QpO1xuICAgIHBhcnNlbGV5X19uYW1lc3BhY2Uubm9ybWFsaXplKGFzdCk7XG4gICAgcmV0dXJuIGFzdDtcbn1cbmZ1bmN0aW9uIHJlZHVjZVNlbGVjdG9yVmFyaWFudHMoYXN0KSB7XG4gICAgY29uc3QgbmV3TGlzdCA9IFtdO1xuICAgIGFzdC5saXN0LmZvckVhY2goc2VsID0+IHtcbiAgICAgICAgc3dpdGNoIChzZWwudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgICAgICAgICAgIG5ld0xpc3QucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZXI6ICd+PScsXG4gICAgICAgICAgICAgICAgICAgIG1vZGlmaWVyOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnY2xhc3MnLFxuICAgICAgICAgICAgICAgICAgICBuYW1lc3BhY2U6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHNwZWNpZmljaXR5OiBzZWwuc3BlY2lmaWNpdHksXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdhdHRyVmFsdWUnLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogc2VsLm5hbWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpZCc6XG4gICAgICAgICAgICAgICAgbmV3TGlzdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcjogJz0nLFxuICAgICAgICAgICAgICAgICAgICBtb2RpZmllcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2lkJyxcbiAgICAgICAgICAgICAgICAgICAgbmFtZXNwYWNlOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBzcGVjaWZpY2l0eTogc2VsLnNwZWNpZmljaXR5LFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYXR0clZhbHVlJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHNlbC5uYW1lLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY29tYmluYXRvcic6XG4gICAgICAgICAgICAgICAgcmVkdWNlU2VsZWN0b3JWYXJpYW50cyhzZWwubGVmdCk7XG4gICAgICAgICAgICAgICAgbmV3TGlzdC5wdXNoKHNlbCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd1bml2ZXJzYWwnOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBuZXdMaXN0LnB1c2goc2VsKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGFzdC5saXN0ID0gbmV3TGlzdDtcbn1cbmZ1bmN0aW9uIHdlYXZlKGl0ZW1zKSB7XG4gICAgY29uc3QgYnJhbmNoZXMgPSBbXTtcbiAgICB3aGlsZSAoaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHRvcEtpbmQgPSBmaW5kVG9wS2V5KGl0ZW1zLCAoc2VsKSA9PiB0cnVlLCBnZXRTZWxlY3RvcktpbmQpO1xuICAgICAgICBjb25zdCB7IG1hdGNoZXMsIG5vbm1hdGNoZXMsIGVtcHR5IH0gPSBicmVha0J5S2luZChpdGVtcywgdG9wS2luZCk7XG4gICAgICAgIGl0ZW1zID0gbm9ubWF0Y2hlcztcbiAgICAgICAgaWYgKG1hdGNoZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBicmFuY2hlcy5wdXNoKGJyYW5jaE9mS2luZCh0b3BLaW5kLCBtYXRjaGVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVtcHR5Lmxlbmd0aCkge1xuICAgICAgICAgICAgYnJhbmNoZXMucHVzaCguLi50ZXJtaW5hdGUoZW1wdHkpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYnJhbmNoZXM7XG59XG5mdW5jdGlvbiB0ZXJtaW5hdGUoaXRlbXMpIHtcbiAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICAgIGNvbnN0IHRlcm1pbmFsID0gaXRlbS50ZXJtaW5hbDtcbiAgICAgICAgaWYgKHRlcm1pbmFsLnR5cGUgPT09ICd0ZXJtaW5hbCcpIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0ZXJtaW5hbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB7IG1hdGNoZXMsIHJlc3QgfSA9IHBhcnRpdGlvbih0ZXJtaW5hbC5jb250LCAobm9kZSkgPT4gbm9kZS50eXBlID09PSAndGVybWluYWwnKTtcbiAgICAgICAgICAgIG1hdGNoZXMuZm9yRWFjaCgobm9kZSkgPT4gcmVzdWx0cy5wdXNoKG5vZGUpKTtcbiAgICAgICAgICAgIGlmIChyZXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRlcm1pbmFsLmNvbnQgPSByZXN0O1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0ZXJtaW5hbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG59XG5mdW5jdGlvbiBicmVha0J5S2luZChpdGVtcywgc2VsZWN0ZWRLaW5kKSB7XG4gICAgY29uc3QgbWF0Y2hlcyA9IFtdO1xuICAgIGNvbnN0IG5vbm1hdGNoZXMgPSBbXTtcbiAgICBjb25zdCBlbXB0eSA9IFtdO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgICBjb25zdCBzaW1wc2VscyA9IGl0ZW0uYXN0Lmxpc3Q7XG4gICAgICAgIGlmIChzaW1wc2Vscy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGlzTWF0Y2ggPSBzaW1wc2Vscy5zb21lKG5vZGUgPT4gZ2V0U2VsZWN0b3JLaW5kKG5vZGUpID09PSBzZWxlY3RlZEtpbmQpO1xuICAgICAgICAgICAgKGlzTWF0Y2ggPyBtYXRjaGVzIDogbm9ubWF0Y2hlcykucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVtcHR5LnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgbWF0Y2hlcywgbm9ubWF0Y2hlcywgZW1wdHkgfTtcbn1cbmZ1bmN0aW9uIGdldFNlbGVjdG9yS2luZChzZWwpIHtcbiAgICBzd2l0Y2ggKHNlbC50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2F0dHJQcmVzZW5jZSc6XG4gICAgICAgICAgICByZXR1cm4gYGF0dHJQcmVzZW5jZSAke3NlbC5uYW1lfWA7XG4gICAgICAgIGNhc2UgJ2F0dHJWYWx1ZSc6XG4gICAgICAgICAgICByZXR1cm4gYGF0dHJWYWx1ZSAke3NlbC5uYW1lfWA7XG4gICAgICAgIGNhc2UgJ2NvbWJpbmF0b3InOlxuICAgICAgICAgICAgcmV0dXJuIGBjb21iaW5hdG9yICR7c2VsLmNvbWJpbmF0b3J9YDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBzZWwudHlwZTtcbiAgICB9XG59XG5mdW5jdGlvbiBicmFuY2hPZktpbmQoa2luZCwgaXRlbXMpIHtcbiAgICBpZiAoa2luZCA9PT0gJ3RhZycpIHtcbiAgICAgICAgcmV0dXJuIHRhZ05hbWVCcmFuY2goaXRlbXMpO1xuICAgIH1cbiAgICBpZiAoa2luZC5zdGFydHNXaXRoKCdhdHRyVmFsdWUgJykpIHtcbiAgICAgICAgcmV0dXJuIGF0dHJWYWx1ZUJyYW5jaChraW5kLnN1YnN0cmluZygxMCksIGl0ZW1zKTtcbiAgICB9XG4gICAgaWYgKGtpbmQuc3RhcnRzV2l0aCgnYXR0clByZXNlbmNlICcpKSB7XG4gICAgICAgIHJldHVybiBhdHRyUHJlc2VuY2VCcmFuY2goa2luZC5zdWJzdHJpbmcoMTMpLCBpdGVtcyk7XG4gICAgfVxuICAgIGlmIChraW5kID09PSAnY29tYmluYXRvciA+Jykge1xuICAgICAgICByZXR1cm4gY29tYmluYXRvckJyYW5jaCgnPicsIGl0ZW1zKTtcbiAgICB9XG4gICAgaWYgKGtpbmQgPT09ICdjb21iaW5hdG9yICsnKSB7XG4gICAgICAgIHJldHVybiBjb21iaW5hdG9yQnJhbmNoKCcrJywgaXRlbXMpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHNlbGVjdG9yIGtpbmQ6ICR7a2luZH1gKTtcbn1cbmZ1bmN0aW9uIHRhZ05hbWVCcmFuY2goaXRlbXMpIHtcbiAgICBjb25zdCBncm91cHMgPSBzcGxpY2VBbmRHcm91cChpdGVtcywgKHgpID0+IHgudHlwZSA9PT0gJ3RhZycsICh4KSA9PiB4Lm5hbWUpO1xuICAgIGNvbnN0IHZhcmlhbnRzID0gT2JqZWN0LmVudHJpZXMoZ3JvdXBzKS5tYXAoKFtuYW1lLCBncm91cF0pID0+ICh7XG4gICAgICAgIHR5cGU6ICd2YXJpYW50JyxcbiAgICAgICAgdmFsdWU6IG5hbWUsXG4gICAgICAgIGNvbnQ6IHdlYXZlKGdyb3VwLml0ZW1zKVxuICAgIH0pKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAndGFnTmFtZScsXG4gICAgICAgIHZhcmlhbnRzOiB2YXJpYW50c1xuICAgIH07XG59XG5mdW5jdGlvbiBhdHRyUHJlc2VuY2VCcmFuY2gobmFtZSwgaXRlbXMpIHtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgICAgc3BsaWNlU2ltcGxlU2VsZWN0b3IoaXRlbSwgKHgpID0+ICh4LnR5cGUgPT09ICdhdHRyUHJlc2VuY2UnKSAmJiAoeC5uYW1lID09PSBuYW1lKSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdhdHRyUHJlc2VuY2UnLFxuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICBjb250OiB3ZWF2ZShpdGVtcylcbiAgICB9O1xufVxuZnVuY3Rpb24gYXR0clZhbHVlQnJhbmNoKG5hbWUsIGl0ZW1zKSB7XG4gICAgY29uc3QgZ3JvdXBzID0gc3BsaWNlQW5kR3JvdXAoaXRlbXMsICh4KSA9PiAoeC50eXBlID09PSAnYXR0clZhbHVlJykgJiYgKHgubmFtZSA9PT0gbmFtZSksICh4KSA9PiBgJHt4Lm1hdGNoZXJ9ICR7eC5tb2RpZmllciB8fCAnJ30gJHt4LnZhbHVlfWApO1xuICAgIGNvbnN0IG1hdGNoZXJzID0gW107XG4gICAgZm9yIChjb25zdCBncm91cCBvZiBPYmplY3QudmFsdWVzKGdyb3VwcykpIHtcbiAgICAgICAgY29uc3Qgc2VsID0gZ3JvdXAub25lU2ltcGxlU2VsZWN0b3I7XG4gICAgICAgIGNvbnN0IHByZWRpY2F0ZSA9IGdldEF0dHJQcmVkaWNhdGUoc2VsKTtcbiAgICAgICAgY29uc3QgY29udGludWF0aW9uID0gd2VhdmUoZ3JvdXAuaXRlbXMpO1xuICAgICAgICBtYXRjaGVycy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdtYXRjaGVyJyxcbiAgICAgICAgICAgIG1hdGNoZXI6IHNlbC5tYXRjaGVyLFxuICAgICAgICAgICAgbW9kaWZpZXI6IHNlbC5tb2RpZmllcixcbiAgICAgICAgICAgIHZhbHVlOiBzZWwudmFsdWUsXG4gICAgICAgICAgICBwcmVkaWNhdGU6IHByZWRpY2F0ZSxcbiAgICAgICAgICAgIGNvbnQ6IGNvbnRpbnVhdGlvblxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2F0dHJWYWx1ZScsXG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIG1hdGNoZXJzOiBtYXRjaGVyc1xuICAgIH07XG59XG5mdW5jdGlvbiBnZXRBdHRyUHJlZGljYXRlKHNlbCkge1xuICAgIGlmIChzZWwubW9kaWZpZXIgPT09ICdpJykge1xuICAgICAgICBjb25zdCBleHBlY3RlZCA9IHNlbC52YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBzd2l0Y2ggKHNlbC5tYXRjaGVyKSB7XG4gICAgICAgICAgICBjYXNlICc9JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gKGFjdHVhbCkgPT4gZXhwZWN0ZWQgPT09IGFjdHVhbC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgY2FzZSAnfj0nOlxuICAgICAgICAgICAgICAgIHJldHVybiAoYWN0dWFsKSA9PiBhY3R1YWwudG9Mb3dlckNhc2UoKS5zcGxpdCgvWyBcXHRdKy8pLmluY2x1ZGVzKGV4cGVjdGVkKTtcbiAgICAgICAgICAgIGNhc2UgJ149JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gKGFjdHVhbCkgPT4gYWN0dWFsLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChleHBlY3RlZCk7XG4gICAgICAgICAgICBjYXNlICckPSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIChhY3R1YWwpID0+IGFjdHVhbC50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKGV4cGVjdGVkKTtcbiAgICAgICAgICAgIGNhc2UgJyo9JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gKGFjdHVhbCkgPT4gYWN0dWFsLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoZXhwZWN0ZWQpO1xuICAgICAgICAgICAgY2FzZSAnfD0nOlxuICAgICAgICAgICAgICAgIHJldHVybiAoYWN0dWFsKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvd2VyID0gYWN0dWFsLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoZXhwZWN0ZWQgPT09IGxvd2VyKSB8fCAobG93ZXIuc3RhcnRzV2l0aChleHBlY3RlZCkgJiYgbG93ZXJbZXhwZWN0ZWQubGVuZ3RoXSA9PT0gJy0nKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBleHBlY3RlZCA9IHNlbC52YWx1ZTtcbiAgICAgICAgc3dpdGNoIChzZWwubWF0Y2hlcikge1xuICAgICAgICAgICAgY2FzZSAnPSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIChhY3R1YWwpID0+IGV4cGVjdGVkID09PSBhY3R1YWw7XG4gICAgICAgICAgICBjYXNlICd+PSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIChhY3R1YWwpID0+IGFjdHVhbC5zcGxpdCgvWyBcXHRdKy8pLmluY2x1ZGVzKGV4cGVjdGVkKTtcbiAgICAgICAgICAgIGNhc2UgJ149JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gKGFjdHVhbCkgPT4gYWN0dWFsLnN0YXJ0c1dpdGgoZXhwZWN0ZWQpO1xuICAgICAgICAgICAgY2FzZSAnJD0nOlxuICAgICAgICAgICAgICAgIHJldHVybiAoYWN0dWFsKSA9PiBhY3R1YWwuZW5kc1dpdGgoZXhwZWN0ZWQpO1xuICAgICAgICAgICAgY2FzZSAnKj0nOlxuICAgICAgICAgICAgICAgIHJldHVybiAoYWN0dWFsKSA9PiBhY3R1YWwuaW5jbHVkZXMoZXhwZWN0ZWQpO1xuICAgICAgICAgICAgY2FzZSAnfD0nOlxuICAgICAgICAgICAgICAgIHJldHVybiAoYWN0dWFsKSA9PiAoZXhwZWN0ZWQgPT09IGFjdHVhbCkgfHwgKGFjdHVhbC5zdGFydHNXaXRoKGV4cGVjdGVkKSAmJiBhY3R1YWxbZXhwZWN0ZWQubGVuZ3RoXSA9PT0gJy0nKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbWJpbmF0b3JCcmFuY2goY29tYmluYXRvciwgaXRlbXMpIHtcbiAgICBjb25zdCBncm91cHMgPSBzcGxpY2VBbmRHcm91cChpdGVtcywgKHgpID0+ICh4LnR5cGUgPT09ICdjb21iaW5hdG9yJykgJiYgKHguY29tYmluYXRvciA9PT0gY29tYmluYXRvciksICh4KSA9PiBwYXJzZWxleV9fbmFtZXNwYWNlLnNlcmlhbGl6ZSh4LmxlZnQpKTtcbiAgICBjb25zdCBsZWZ0SXRlbXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIE9iamVjdC52YWx1ZXMoZ3JvdXBzKSkge1xuICAgICAgICBjb25zdCByaWdodENvbnQgPSB3ZWF2ZShncm91cC5pdGVtcyk7XG4gICAgICAgIGNvbnN0IGxlZnRBc3QgPSBncm91cC5vbmVTaW1wbGVTZWxlY3Rvci5sZWZ0O1xuICAgICAgICBsZWZ0SXRlbXMucHVzaCh7XG4gICAgICAgICAgICBhc3Q6IGxlZnRBc3QsXG4gICAgICAgICAgICB0ZXJtaW5hbDogeyB0eXBlOiAncG9wRWxlbWVudCcsIGNvbnQ6IHJpZ2h0Q29udCB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAncHVzaEVsZW1lbnQnLFxuICAgICAgICBjb21iaW5hdG9yOiBjb21iaW5hdG9yLFxuICAgICAgICBjb250OiB3ZWF2ZShsZWZ0SXRlbXMpXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHNwbGljZUFuZEdyb3VwKGl0ZW1zLCBwcmVkaWNhdGUsIGtleUNhbGxiYWNrKSB7XG4gICAgY29uc3QgZ3JvdXBzID0ge307XG4gICAgd2hpbGUgKGl0ZW1zLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBiZXN0S2V5ID0gZmluZFRvcEtleShpdGVtcywgcHJlZGljYXRlLCBrZXlDYWxsYmFjayk7XG4gICAgICAgIGNvbnN0IGJlc3RLZXlQcmVkaWNhdGUgPSAoc2VsKSA9PiBwcmVkaWNhdGUoc2VsKSAmJiBrZXlDYWxsYmFjayhzZWwpID09PSBiZXN0S2V5O1xuICAgICAgICBjb25zdCBoYXNCZXN0S2V5UHJlZGljYXRlID0gKGl0ZW0pID0+IGl0ZW0uYXN0Lmxpc3Quc29tZShiZXN0S2V5UHJlZGljYXRlKTtcbiAgICAgICAgY29uc3QgeyBtYXRjaGVzLCByZXN0IH0gPSBwYXJ0aXRpb24xKGl0ZW1zLCBoYXNCZXN0S2V5UHJlZGljYXRlKTtcbiAgICAgICAgbGV0IG9uZVNpbXBsZVNlbGVjdG9yID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIG1hdGNoZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNwbGljZWROb2RlID0gc3BsaWNlU2ltcGxlU2VsZWN0b3IoaXRlbSwgYmVzdEtleVByZWRpY2F0ZSk7XG4gICAgICAgICAgICBpZiAoIW9uZVNpbXBsZVNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgb25lU2ltcGxlU2VsZWN0b3IgPSBzcGxpY2VkTm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob25lU2ltcGxlU2VsZWN0b3IgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBzaW1wbGUgc2VsZWN0b3IgaXMgZm91bmQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZ3JvdXBzW2Jlc3RLZXldID0geyBvbmVTaW1wbGVTZWxlY3Rvcjogb25lU2ltcGxlU2VsZWN0b3IsIGl0ZW1zOiBtYXRjaGVzIH07XG4gICAgICAgIGl0ZW1zID0gcmVzdDtcbiAgICB9XG4gICAgcmV0dXJuIGdyb3Vwcztcbn1cbmZ1bmN0aW9uIHNwbGljZVNpbXBsZVNlbGVjdG9yKGl0ZW0sIHByZWRpY2F0ZSkge1xuICAgIGNvbnN0IHNpbXBzZWxzID0gaXRlbS5hc3QubGlzdDtcbiAgICBjb25zdCBtYXRjaGVzID0gbmV3IEFycmF5KHNpbXBzZWxzLmxlbmd0aCk7XG4gICAgbGV0IGZpcnN0SW5kZXggPSAtMTtcbiAgICBmb3IgKGxldCBpID0gc2ltcHNlbHMubGVuZ3RoOyBpLS0gPiAwOykge1xuICAgICAgICBpZiAocHJlZGljYXRlKHNpbXBzZWxzW2ldKSkge1xuICAgICAgICAgICAgbWF0Y2hlc1tpXSA9IHRydWU7XG4gICAgICAgICAgICBmaXJzdEluZGV4ID0gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZmlyc3RJbmRleCA9PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkbid0IGZpbmQgdGhlIHJlcXVpcmVkIHNpbXBsZSBzZWxlY3Rvci5gKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gc2ltcHNlbHNbZmlyc3RJbmRleF07XG4gICAgaXRlbS5hc3QubGlzdCA9IHNpbXBzZWxzLmZpbHRlcigoc2VsLCBpKSA9PiAhbWF0Y2hlc1tpXSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGZpbmRUb3BLZXkoaXRlbXMsIHByZWRpY2F0ZSwga2V5Q2FsbGJhY2spIHtcbiAgICBjb25zdCBjYW5kaWRhdGVzID0ge307XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZXMxID0ge307XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBpdGVtLmFzdC5saXN0LmZpbHRlcihwcmVkaWNhdGUpKSB7XG4gICAgICAgICAgICBjYW5kaWRhdGVzMVtrZXlDYWxsYmFjayhub2RlKV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGNhbmRpZGF0ZXMxKSkge1xuICAgICAgICAgICAgaWYgKGNhbmRpZGF0ZXNba2V5XSkge1xuICAgICAgICAgICAgICAgIGNhbmRpZGF0ZXNba2V5XSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FuZGlkYXRlc1trZXldID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgdG9wS2luZCA9ICcnO1xuICAgIGxldCB0b3BDb3VudGVyID0gMDtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIE9iamVjdC5lbnRyaWVzKGNhbmRpZGF0ZXMpKSB7XG4gICAgICAgIGlmIChlbnRyeVsxXSA+IHRvcENvdW50ZXIpIHtcbiAgICAgICAgICAgIHRvcEtpbmQgPSBlbnRyeVswXTtcbiAgICAgICAgICAgIHRvcENvdW50ZXIgPSBlbnRyeVsxXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG9wS2luZDtcbn1cbmZ1bmN0aW9uIHBhcnRpdGlvbihzcmMsIHByZWRpY2F0ZSkge1xuICAgIGNvbnN0IG1hdGNoZXMgPSBbXTtcbiAgICBjb25zdCByZXN0ID0gW107XG4gICAgZm9yIChjb25zdCB4IG9mIHNyYykge1xuICAgICAgICBpZiAocHJlZGljYXRlKHgpKSB7XG4gICAgICAgICAgICBtYXRjaGVzLnB1c2goeCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN0LnB1c2goeCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgbWF0Y2hlcywgcmVzdCB9O1xufVxuZnVuY3Rpb24gcGFydGl0aW9uMShzcmMsIHByZWRpY2F0ZSkge1xuICAgIGNvbnN0IG1hdGNoZXMgPSBbXTtcbiAgICBjb25zdCByZXN0ID0gW107XG4gICAgZm9yIChjb25zdCB4IG9mIHNyYykge1xuICAgICAgICBpZiAocHJlZGljYXRlKHgpKSB7XG4gICAgICAgICAgICBtYXRjaGVzLnB1c2goeCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN0LnB1c2goeCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgbWF0Y2hlcywgcmVzdCB9O1xufVxuXG5jbGFzcyBQaWNrZXIge1xuICAgIGNvbnN0cnVjdG9yKGYpIHtcbiAgICAgICAgdGhpcy5mID0gZjtcbiAgICB9XG4gICAgcGlja0FsbChlbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mKGVsKTtcbiAgICB9XG4gICAgcGljazEoZWwsIHByZWZlckZpcnN0ID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IHRoaXMuZihlbCk7XG4gICAgICAgIGNvbnN0IGxlbiA9IHJlc3VsdHMubGVuZ3RoO1xuICAgICAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0c1swXS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb21wYXJhdG9yID0gKHByZWZlckZpcnN0KVxuICAgICAgICAgICAgPyBjb21wYXJhdG9yUHJlZmVyRmlyc3RcbiAgICAgICAgICAgIDogY29tcGFyYXRvclByZWZlckxhc3Q7XG4gICAgICAgIGxldCByZXN1bHQgPSByZXN1bHRzWzBdO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gcmVzdWx0c1tpXTtcbiAgICAgICAgICAgIGlmIChjb21wYXJhdG9yKHJlc3VsdCwgbmV4dCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQudmFsdWU7XG4gICAgfVxufVxuZnVuY3Rpb24gY29tcGFyYXRvclByZWZlckZpcnN0KGFjYywgbmV4dCkge1xuICAgIGNvbnN0IGRpZmYgPSBwYXJzZWxleS5jb21wYXJlU3BlY2lmaWNpdHkobmV4dC5zcGVjaWZpY2l0eSwgYWNjLnNwZWNpZmljaXR5KTtcbiAgICByZXR1cm4gZGlmZiA+IDAgfHwgKGRpZmYgPT09IDAgJiYgbmV4dC5pbmRleCA8IGFjYy5pbmRleCk7XG59XG5mdW5jdGlvbiBjb21wYXJhdG9yUHJlZmVyTGFzdChhY2MsIG5leHQpIHtcbiAgICBjb25zdCBkaWZmID0gcGFyc2VsZXkuY29tcGFyZVNwZWNpZmljaXR5KG5leHQuc3BlY2lmaWNpdHksIGFjYy5zcGVjaWZpY2l0eSk7XG4gICAgcmV0dXJuIGRpZmYgPiAwIHx8IChkaWZmID09PSAwICYmIG5leHQuaW5kZXggPiBhY2MuaW5kZXgpO1xufVxuXG5leHBvcnRzLkFzdCA9IEFzdDtcbmV4cG9ydHMuRGVjaXNpb25UcmVlID0gRGVjaXNpb25UcmVlO1xuZXhwb3J0cy5QaWNrZXIgPSBQaWNrZXI7XG5leHBvcnRzLlRyZWVpZnkgPSBUcmVlaWZ5QnVpbGRlcjtcbmV4cG9ydHMuVHlwZXMgPSBUeXBlcztcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInBhcnNlbGV5IiwicmVxdWlyZSIsIl9pbnRlcm9wTmFtZXNwYWNlIiwiZSIsIl9fZXNNb2R1bGUiLCJuIiwiY3JlYXRlIiwia2V5cyIsImZvckVhY2giLCJrIiwiZCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImdldCIsImVudW1lcmFibGUiLCJmcmVlemUiLCJwYXJzZWxleV9fbmFtZXNwYWNlIiwiQXN0IiwiX19wcm90b19fIiwiVHlwZXMiLCJ0cmVlaWZ5Iiwibm9kZXMiLCJ0cmVlaWZ5QXJyYXkiLCJ0aGluTGluZXMiLCJoZWF2eUxpbmVzIiwiZG91YmxlTGluZXMiLCJ0cGwiLCJwcmVmaXhJdGVtcyIsIm1hcCIsInRyZWVpZnlOb2RlIiwibm9kZSIsInR5cGUiLCJ2Y3RyIiwidmFsdWVDb250YWluZXIiLCJpbmRleCIsIkpTT04iLCJzdHJpbmdpZnkiLCJzcGVjaWZpY2l0eSIsInZhcmlhbnRzIiwibmFtZSIsIm1hdGNoZXJzIiwiY29udCIsImNvbWJpbmF0b3IiLCJtYXRjaGVyIiwibW9kaWZpZXIiLCJpdGVtcyIsIml0ZW0iLCJpIiwibGVuZ3RoIiwicHJlZml4SXRlbSIsImpvaW4iLCJ0YWlsIiwidHBsMSIsInNwbGl0IiwiVHJlZWlmeUJ1aWxkZXIiLCJEZWNpc2lvblRyZWUiLCJjb25zdHJ1Y3RvciIsImlucHV0IiwiYnJhbmNoZXMiLCJ3ZWF2ZSIsInRvQXN0VGVybWluYWxQYWlycyIsImJ1aWxkIiwiYnVpbGRlciIsImFycmF5IiwibGVuIiwicmVzdWx0cyIsIkFycmF5Iiwic2VsZWN0b3JTdHJpbmciLCJ2YWwiLCJhc3QiLCJwcmVwcm9jZXNzIiwicGFyc2UxIiwidGVybWluYWwiLCJyZWR1Y2VTZWxlY3RvclZhcmlhbnRzIiwibm9ybWFsaXplIiwibmV3TGlzdCIsImxpc3QiLCJzZWwiLCJwdXNoIiwibmFtZXNwYWNlIiwibGVmdCIsInRvcEtpbmQiLCJmaW5kVG9wS2V5IiwiZ2V0U2VsZWN0b3JLaW5kIiwibWF0Y2hlcyIsIm5vbm1hdGNoZXMiLCJlbXB0eSIsImJyZWFrQnlLaW5kIiwiYnJhbmNoT2ZLaW5kIiwidGVybWluYXRlIiwicmVzdCIsInBhcnRpdGlvbiIsInNlbGVjdGVkS2luZCIsInNpbXBzZWxzIiwiaXNNYXRjaCIsInNvbWUiLCJraW5kIiwidGFnTmFtZUJyYW5jaCIsInN0YXJ0c1dpdGgiLCJhdHRyVmFsdWVCcmFuY2giLCJzdWJzdHJpbmciLCJhdHRyUHJlc2VuY2VCcmFuY2giLCJjb21iaW5hdG9yQnJhbmNoIiwiRXJyb3IiLCJncm91cHMiLCJzcGxpY2VBbmRHcm91cCIsIngiLCJlbnRyaWVzIiwiZ3JvdXAiLCJzcGxpY2VTaW1wbGVTZWxlY3RvciIsInZhbHVlcyIsIm9uZVNpbXBsZVNlbGVjdG9yIiwicHJlZGljYXRlIiwiZ2V0QXR0clByZWRpY2F0ZSIsImNvbnRpbnVhdGlvbiIsImV4cGVjdGVkIiwidG9Mb3dlckNhc2UiLCJhY3R1YWwiLCJpbmNsdWRlcyIsImVuZHNXaXRoIiwibG93ZXIiLCJzZXJpYWxpemUiLCJsZWZ0SXRlbXMiLCJyaWdodENvbnQiLCJsZWZ0QXN0Iiwia2V5Q2FsbGJhY2siLCJiZXN0S2V5IiwiYmVzdEtleVByZWRpY2F0ZSIsImhhc0Jlc3RLZXlQcmVkaWNhdGUiLCJwYXJ0aXRpb24xIiwic3BsaWNlZE5vZGUiLCJmaXJzdEluZGV4IiwicmVzdWx0IiwiZmlsdGVyIiwiY2FuZGlkYXRlcyIsImNhbmRpZGF0ZXMxIiwia2V5IiwidG9wQ291bnRlciIsImVudHJ5Iiwic3JjIiwiUGlja2VyIiwiZiIsInBpY2tBbGwiLCJlbCIsInBpY2sxIiwicHJlZmVyRmlyc3QiLCJjb21wYXJhdG9yIiwiY29tcGFyYXRvclByZWZlckZpcnN0IiwiY29tcGFyYXRvclByZWZlckxhc3QiLCJuZXh0IiwiYWNjIiwiZGlmZiIsImNvbXBhcmVTcGVjaWZpY2l0eSIsIlRyZWVpZnkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/selderee/lib/selderee.cjs\n");

/***/ })

};
;