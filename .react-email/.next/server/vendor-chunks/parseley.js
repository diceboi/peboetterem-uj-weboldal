"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/parseley";
exports.ids = ["vendor-chunks/parseley"];
exports.modules = {

/***/ "(rsc)/./node_modules/parseley/lib/parseley.cjs":
/*!************************************************!*\
  !*** ./node_modules/parseley/lib/parseley.cjs ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar leac = __webpack_require__(/*! leac */ \"(rsc)/./node_modules/leac/lib/leac.cjs\");\nvar p = __webpack_require__(/*! peberminta */ \"(rsc)/./node_modules/peberminta/lib/core.cjs\");\nfunction _interopNamespace(e) {\n    if (e && e.__esModule) return e;\n    var n = Object.create(null);\n    if (e) {\n        Object.keys(e).forEach(function(k) {\n            if (k !== \"default\") {\n                var d = Object.getOwnPropertyDescriptor(e, k);\n                Object.defineProperty(n, k, d.get ? d : {\n                    enumerable: true,\n                    get: function() {\n                        return e[k];\n                    }\n                });\n            }\n        });\n    }\n    n[\"default\"] = e;\n    return Object.freeze(n);\n}\nvar p__namespace = /*#__PURE__*/ _interopNamespace(p);\nvar ast = /*#__PURE__*/ Object.freeze({\n    __proto__: null\n});\nconst lex = leac.createLexer([\n    {\n        name: \"ws\",\n        regex: /[ \\t\\r\\n\\f]+/\n    },\n    {\n        name: \"idn\",\n        regex: /[a-zA-Z_-][a-zA-Z0-9_-]*/\n    },\n    {\n        name: \"#id\",\n        regex: /#[a-zA-Z0-9_-]+/\n    },\n    {\n        name: \"str1\",\n        regex: /'(?:\\\\['\\\\]|[^\\n'\\\\])*'/\n    },\n    {\n        name: \"str2\",\n        regex: /\"(?:\\\\[\"\\\\]|[^\\n\"\\\\])*\"/\n    },\n    {\n        name: \"*\"\n    },\n    {\n        name: \".\"\n    },\n    {\n        name: \",\"\n    },\n    {\n        name: \"[\"\n    },\n    {\n        name: \"]\"\n    },\n    {\n        name: \"=\"\n    },\n    {\n        name: \">\"\n    },\n    {\n        name: \"|\"\n    },\n    {\n        name: \"+\"\n    },\n    {\n        name: \"~\"\n    },\n    {\n        name: \"^\"\n    },\n    {\n        name: \"$\"\n    }\n]);\nfunction sumSpec([a0, a1, a2], [b0, b1, b2]) {\n    return [\n        a0 + b0,\n        a1 + b1,\n        a2 + b2\n    ];\n}\nfunction sumAllSpec(ss) {\n    return ss.reduce(sumSpec, [\n        0,\n        0,\n        0\n    ]);\n}\nfunction literal(name) {\n    return p__namespace.token((t)=>t.name === name ? true : undefined);\n}\nconst whitespace_ = p__namespace.token((t)=>t.name === \"ws\" ? null : undefined);\nconst optionalWhitespace_ = p__namespace.option(whitespace_, null);\nfunction optionallySpaced(parser) {\n    return p__namespace.middle(optionalWhitespace_, parser, optionalWhitespace_);\n}\nconst identifier_ = p__namespace.token((t)=>t.name === \"idn\" ? t.text : undefined);\nconst hashId_ = p__namespace.token((t)=>t.name === \"#id\" ? t.text.slice(1) : undefined);\nconst string_ = p__namespace.token((t)=>t.name.startsWith(\"str\") ? t.text.slice(1, -1) : undefined);\nconst namespace_ = p__namespace.left(p__namespace.option(identifier_, \"\"), literal(\"|\"));\nconst qualifiedName_ = p__namespace.eitherOr(p__namespace.ab(namespace_, identifier_, (ns, name)=>({\n        name: name,\n        namespace: ns\n    })), p__namespace.map(identifier_, (name)=>({\n        name: name,\n        namespace: null\n    })));\nconst uniSelector_ = p__namespace.eitherOr(p__namespace.ab(namespace_, literal(\"*\"), (ns)=>({\n        type: \"universal\",\n        namespace: ns,\n        specificity: [\n            0,\n            0,\n            0\n        ]\n    })), p__namespace.map(literal(\"*\"), ()=>({\n        type: \"universal\",\n        namespace: null,\n        specificity: [\n            0,\n            0,\n            0\n        ]\n    })));\nconst tagSelector_ = p__namespace.map(qualifiedName_, ({ name, namespace })=>({\n        type: \"tag\",\n        name: name,\n        namespace: namespace,\n        specificity: [\n            0,\n            0,\n            1\n        ]\n    }));\nconst classSelector_ = p__namespace.ab(literal(\".\"), identifier_, (fullstop, name)=>({\n        type: \"class\",\n        name: name,\n        specificity: [\n            0,\n            1,\n            0\n        ]\n    }));\nconst idSelector_ = p__namespace.map(hashId_, (name)=>({\n        type: \"id\",\n        name: name,\n        specificity: [\n            1,\n            0,\n            0\n        ]\n    }));\nconst attrModifier_ = p__namespace.token((t)=>{\n    if (t.name === \"idn\") {\n        if (t.text === \"i\" || t.text === \"I\") {\n            return \"i\";\n        }\n        if (t.text === \"s\" || t.text === \"S\") {\n            return \"s\";\n        }\n    }\n    return undefined;\n});\nconst attrValue_ = p__namespace.eitherOr(p__namespace.ab(string_, p__namespace.option(p__namespace.right(optionalWhitespace_, attrModifier_), null), (v, mod)=>({\n        value: v,\n        modifier: mod\n    })), p__namespace.ab(identifier_, p__namespace.option(p__namespace.right(whitespace_, attrModifier_), null), (v, mod)=>({\n        value: v,\n        modifier: mod\n    })));\nconst attrMatcher_ = p__namespace.choice(p__namespace.map(literal(\"=\"), ()=>\"=\"), p__namespace.ab(literal(\"~\"), literal(\"=\"), ()=>\"~=\"), p__namespace.ab(literal(\"|\"), literal(\"=\"), ()=>\"|=\"), p__namespace.ab(literal(\"^\"), literal(\"=\"), ()=>\"^=\"), p__namespace.ab(literal(\"$\"), literal(\"=\"), ()=>\"$=\"), p__namespace.ab(literal(\"*\"), literal(\"=\"), ()=>\"*=\"));\nconst attrPresenceSelector_ = p__namespace.abc(literal(\"[\"), optionallySpaced(qualifiedName_), literal(\"]\"), (lbr, { name, namespace })=>({\n        type: \"attrPresence\",\n        name: name,\n        namespace: namespace,\n        specificity: [\n            0,\n            1,\n            0\n        ]\n    }));\nconst attrValueSelector_ = p__namespace.middle(literal(\"[\"), p__namespace.abc(optionallySpaced(qualifiedName_), attrMatcher_, optionallySpaced(attrValue_), ({ name, namespace }, matcher, { value, modifier })=>({\n        type: \"attrValue\",\n        name: name,\n        namespace: namespace,\n        matcher: matcher,\n        value: value,\n        modifier: modifier,\n        specificity: [\n            0,\n            1,\n            0\n        ]\n    })), literal(\"]\"));\nconst attrSelector_ = p__namespace.eitherOr(attrPresenceSelector_, attrValueSelector_);\nconst typeSelector_ = p__namespace.eitherOr(uniSelector_, tagSelector_);\nconst subclassSelector_ = p__namespace.choice(idSelector_, classSelector_, attrSelector_);\nconst compoundSelector_ = p__namespace.map(p__namespace.eitherOr(p__namespace.flatten(typeSelector_, p__namespace.many(subclassSelector_)), p__namespace.many1(subclassSelector_)), (ss)=>{\n    return {\n        type: \"compound\",\n        list: ss,\n        specificity: sumAllSpec(ss.map((s)=>s.specificity))\n    };\n});\nconst combinator_ = p__namespace.choice(p__namespace.map(literal(\">\"), ()=>\">\"), p__namespace.map(literal(\"+\"), ()=>\"+\"), p__namespace.map(literal(\"~\"), ()=>\"~\"), p__namespace.ab(literal(\"|\"), literal(\"|\"), ()=>\"||\"));\nconst combinatorSeparator_ = p__namespace.eitherOr(optionallySpaced(combinator_), p__namespace.map(whitespace_, ()=>\" \"));\nconst complexSelector_ = p__namespace.leftAssoc2(compoundSelector_, p__namespace.map(combinatorSeparator_, (c)=>(left, right)=>({\n            type: \"compound\",\n            list: [\n                ...right.list,\n                {\n                    type: \"combinator\",\n                    combinator: c,\n                    left: left,\n                    specificity: left.specificity\n                }\n            ],\n            specificity: sumSpec(left.specificity, right.specificity)\n        })), compoundSelector_);\nconst listSelector_ = p__namespace.leftAssoc2(p__namespace.map(complexSelector_, (s)=>({\n        type: \"list\",\n        list: [\n            s\n        ]\n    })), p__namespace.map(optionallySpaced(literal(\",\")), ()=>(acc, next)=>({\n            type: \"list\",\n            list: [\n                ...acc.list,\n                next\n            ]\n        })), complexSelector_);\nfunction parse_(parser, str) {\n    const lexerResult = lex(str);\n    if (!lexerResult.complete) {\n        throw new Error(`The input \"${str}\" was only partially tokenized, stopped at offset ${lexerResult.offset}!\\n` + prettyPrintPosition(str, lexerResult.offset));\n    }\n    const result = optionallySpaced(parser)({\n        tokens: lexerResult.tokens,\n        options: undefined\n    }, 0);\n    if (!result.matched) {\n        throw new Error(`No match for \"${str}\" input!`);\n    }\n    if (result.position < lexerResult.tokens.length) {\n        const token = lexerResult.tokens[result.position];\n        throw new Error(`The input \"${str}\" was only partially parsed, stopped at offset ${token.offset}!\\n` + prettyPrintPosition(str, token.offset, token.len));\n    }\n    return result.value;\n}\nfunction prettyPrintPosition(str, offset, len = 1) {\n    return `${str.replace(/(\\t)|(\\r)|(\\n)/g, (m, t, r)=>t ? \"␉\" : r ? \"␍\" : \"␊\")}\\n${\"\".padEnd(offset)}${\"^\".repeat(len)}`;\n}\nfunction parse(str) {\n    return parse_(listSelector_, str);\n}\nfunction parse1(str) {\n    return parse_(complexSelector_, str);\n}\nfunction serialize(selector) {\n    if (!selector.type) {\n        throw new Error(\"This is not an AST node.\");\n    }\n    switch(selector.type){\n        case \"universal\":\n            return _serNs(selector.namespace) + \"*\";\n        case \"tag\":\n            return _serNs(selector.namespace) + selector.name;\n        case \"class\":\n            return \".\" + selector.name;\n        case \"id\":\n            return \"#\" + selector.name;\n        case \"attrPresence\":\n            return `[${_serNs(selector.namespace)}${selector.name}]`;\n        case \"attrValue\":\n            return `[${_serNs(selector.namespace)}${selector.name}${selector.matcher}${_serStr(selector.value)}${selector.modifier ? selector.modifier : \"\"}]`;\n        case \"combinator\":\n            return serialize(selector.left) + selector.combinator;\n        case \"compound\":\n            return selector.list.reduce((acc, node)=>{\n                if (node.type === \"combinator\") {\n                    return serialize(node) + acc;\n                } else {\n                    return acc + serialize(node);\n                }\n            }, \"\");\n        case \"list\":\n            return selector.list.map(serialize).join(\",\");\n    }\n}\nfunction _serNs(ns) {\n    return ns || ns === \"\" ? ns + \"|\" : \"\";\n}\nfunction _serStr(str) {\n    if (str.indexOf('\"') === -1) {\n        return `\"${str}\"`;\n    } else if (str.indexOf(\"'\") === -1) {\n        return `'${str}'`;\n    } else {\n        return `\"${str.replace('\"', '\\\\\"')}\"`;\n    }\n}\nfunction normalize(selector) {\n    if (!selector.type) {\n        throw new Error(\"This is not an AST node.\");\n    }\n    switch(selector.type){\n        case \"compound\":\n            {\n                selector.list.forEach(normalize);\n                selector.list.sort((a, b)=>_compareArrays(_getSelectorPriority(a), _getSelectorPriority(b)));\n                break;\n            }\n        case \"combinator\":\n            {\n                normalize(selector.left);\n                break;\n            }\n        case \"list\":\n            {\n                selector.list.forEach(normalize);\n                selector.list.sort((a, b)=>serialize(a) < serialize(b) ? -1 : 1);\n                break;\n            }\n    }\n    return selector;\n}\nfunction _getSelectorPriority(selector) {\n    switch(selector.type){\n        case \"universal\":\n            return [\n                1\n            ];\n        case \"tag\":\n            return [\n                1\n            ];\n        case \"id\":\n            return [\n                2\n            ];\n        case \"class\":\n            return [\n                3,\n                selector.name\n            ];\n        case \"attrPresence\":\n            return [\n                4,\n                serialize(selector)\n            ];\n        case \"attrValue\":\n            return [\n                5,\n                serialize(selector)\n            ];\n        case \"combinator\":\n            return [\n                15,\n                serialize(selector)\n            ];\n    }\n}\nfunction compareSelectors(a, b) {\n    return _compareArrays(a.specificity, b.specificity);\n}\nfunction compareSpecificity(a, b) {\n    return _compareArrays(a, b);\n}\nfunction _compareArrays(a, b) {\n    if (!Array.isArray(a) || !Array.isArray(b)) {\n        throw new Error(\"Arguments must be arrays.\");\n    }\n    const shorter = a.length < b.length ? a.length : b.length;\n    for(let i = 0; i < shorter; i++){\n        if (a[i] === b[i]) {\n            continue;\n        }\n        return a[i] < b[i] ? -1 : 1;\n    }\n    return a.length - b.length;\n}\nexports.Ast = ast;\nexports.compareSelectors = compareSelectors;\nexports.compareSpecificity = compareSpecificity;\nexports.normalize = normalize;\nexports.parse = parse;\nexports.parse1 = parse1;\nexports.serialize = serialize;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGFyc2VsZXkvbGliL3BhcnNlbGV5LmNqcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUU3RCxJQUFJQyxPQUFPQyxtQkFBT0EsQ0FBQztBQUNuQixJQUFJQyxJQUFJRCxtQkFBT0EsQ0FBQztBQUVoQixTQUFTRSxrQkFBa0JDLENBQUM7SUFDeEIsSUFBSUEsS0FBS0EsRUFBRUMsVUFBVSxFQUFFLE9BQU9EO0lBQzlCLElBQUlFLElBQUlWLE9BQU9XLE1BQU0sQ0FBQztJQUN0QixJQUFJSCxHQUFHO1FBQ0hSLE9BQU9ZLElBQUksQ0FBQ0osR0FBR0ssT0FBTyxDQUFDLFNBQVVDLENBQUM7WUFDOUIsSUFBSUEsTUFBTSxXQUFXO2dCQUNqQixJQUFJQyxJQUFJZixPQUFPZ0Isd0JBQXdCLENBQUNSLEdBQUdNO2dCQUMzQ2QsT0FBT0MsY0FBYyxDQUFDUyxHQUFHSSxHQUFHQyxFQUFFRSxHQUFHLEdBQUdGLElBQUk7b0JBQ3BDRyxZQUFZO29CQUNaRCxLQUFLO3dCQUFjLE9BQU9ULENBQUMsQ0FBQ00sRUFBRTtvQkFBRTtnQkFDcEM7WUFDSjtRQUNKO0lBQ0o7SUFDQUosQ0FBQyxDQUFDLFVBQVUsR0FBR0Y7SUFDZixPQUFPUixPQUFPbUIsTUFBTSxDQUFDVDtBQUN6QjtBQUVBLElBQUlVLGVBQWUsV0FBVyxHQUFFYixrQkFBa0JEO0FBRWxELElBQUllLE1BQU0sV0FBVyxHQUFFckIsT0FBT21CLE1BQU0sQ0FBQztJQUNqQ0csV0FBVztBQUNmO0FBRUEsTUFBTUMsTUFBTW5CLEtBQUtvQixXQUFXLENBQUM7SUFDekI7UUFBRUMsTUFBTTtRQUFNQyxPQUFPO0lBQWU7SUFDcEM7UUFBRUQsTUFBTTtRQUFPQyxPQUFPO0lBQTJCO0lBQ2pEO1FBQUVELE1BQU07UUFBT0MsT0FBTztJQUFrQjtJQUN4QztRQUFFRCxNQUFNO1FBQVFDLE9BQU87SUFBMEI7SUFDakQ7UUFBRUQs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STJCLElBQUksR0FBR0EsSUFBSUQsU0FBU0MsSUFBSztRQUM5QixJQUFJVCxDQUFDLENBQUNTLEVBQUUsS0FBS1IsQ0FBQyxDQUFDUSxFQUFFLEVBQUU7WUFDZjtRQUNKO1FBQ0EsT0FBTyxDQUFFLENBQUNBLEVBQUUsR0FBR1IsQ0FBQyxDQUFDUSxFQUFFLEdBQUksQ0FBQyxJQUFJO0lBQ2hDO0lBQ0EsT0FBT1QsRUFBRWxCLE1BQU0sR0FBR21CLEVBQUVuQixNQUFNO0FBQzlCO0FBRUE3RyxXQUFXLEdBQUdtQjtBQUNkbkIsd0JBQXdCLEdBQUdtSTtBQUMzQm5JLDBCQUEwQixHQUFHb0k7QUFDN0JwSSxpQkFBaUIsR0FBRzZIO0FBQ3BCN0gsYUFBYSxHQUFHb0g7QUFDaEJwSCxjQUFjLEdBQUdxSDtBQUNqQnJILGlCQUFpQixHQUFHc0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1lbWFpbC1jbGllbnQvLi9ub2RlX21vZHVsZXMvcGFyc2VsZXkvbGliL3BhcnNlbGV5LmNqcz9lNTllIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGxlYWMgPSByZXF1aXJlKCdsZWFjJyk7XG52YXIgcCA9IHJlcXVpcmUoJ3BlYmVybWludGEnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BOYW1lc3BhY2UoZSkge1xuICAgIGlmIChlICYmIGUuX19lc01vZHVsZSkgcmV0dXJuIGU7XG4gICAgdmFyIG4gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGlmIChlKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKGUpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIGlmIChrICE9PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgICAgICAgICB2YXIgZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgayk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIGssIGQuZ2V0ID8gZCA6IHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlW2tdOyB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBuW1wiZGVmYXVsdFwiXSA9IGU7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUobik7XG59XG5cbnZhciBwX19uYW1lc3BhY2UgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BOYW1lc3BhY2UocCk7XG5cbnZhciBhc3QgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsXG59KTtcblxuY29uc3QgbGV4ID0gbGVhYy5jcmVhdGVMZXhlcihbXG4gICAgeyBuYW1lOiAnd3MnLCByZWdleDogL1sgXFx0XFxyXFxuXFxmXSsvIH0sXG4gICAgeyBuYW1lOiAnaWRuJywgcmVnZXg6IC9bYS16QS1aXy1dW2EtekEtWjAtOV8tXSovIH0sXG4gICAgeyBuYW1lOiAnI2lkJywgcmVnZXg6IC8jW2EtekEtWjAtOV8tXSsvIH0sXG4gICAgeyBuYW1lOiAnc3RyMScsIHJlZ2V4OiAvJyg/OlxcXFxbJ1xcXFxdfFteXFxuJ1xcXFxdKSonLyB9LFxuICAgIHsgbmFtZTogJ3N0cjInLCByZWdleDogL1wiKD86XFxcXFtcIlxcXFxdfFteXFxuXCJcXFxcXSkqXCIvIH0sXG4gICAgeyBuYW1lOiAnKicgfSxcbiAgICB7IG5hbWU6ICcuJyB9LFxuICAgIHsgbmFtZTogJywnIH0sXG4gICAgeyBuYW1lOiAnWycgfSxcbiAgICB7IG5hbWU6ICddJyB9LFxuICAgIHsgbmFtZTogJz0nIH0sXG4gICAgeyBuYW1lOiAnPicgfSxcbiAgICB7IG5hbWU6ICd8JyB9LFxuICAgIHsgbmFtZTogJysnIH0sXG4gICAgeyBuYW1lOiAnficgfSxcbiAgICB7IG5hbWU6ICdeJyB9LFxuICAgIHsgbmFtZTogJyQnIH0sXG5dKTtcbmZ1bmN0aW9uIHN1bVNwZWMoW2EwLCBhMSwgYTJdLCBbYjAsIGIxLCBiMl0pIHtcbiAgICByZXR1cm4gW2EwICsgYjAsIGExICsgYjEsIGEyICsgYjJdO1xufVxuZnVuY3Rpb24gc3VtQWxsU3BlYyhzcykge1xuICAgIHJldHVybiBzcy5yZWR1Y2Uoc3VtU3BlYywgWzAsIDAsIDBdKTtcbn1cbmZ1bmN0aW9uIGxpdGVyYWwobmFtZSkge1xuICAgIHJldHVybiBwX19uYW1lc3BhY2UudG9rZW4oKHQpID0+IHQubmFtZSA9PT0gbmFtZSA/IHRydWUgOiB1bmRlZmluZWQpO1xufVxuY29uc3Qgd2hpdGVzcGFjZV8gPSBwX19uYW1lc3BhY2UudG9rZW4oKHQpID0+IHQubmFtZSA9PT0gJ3dzJyA/IG51bGwgOiB1bmRlZmluZWQpO1xuY29uc3Qgb3B0aW9uYWxXaGl0ZXNwYWNlXyA9IHBfX25hbWVzcGFjZS5vcHRpb24od2hpdGVzcGFjZV8sIG51bGwpO1xuZnVuY3Rpb24gb3B0aW9uYWxseVNwYWNlZChwYXJzZXIpIHtcbiAgICByZXR1cm4gcF9fbmFtZXNwYWNlLm1pZGRsZShvcHRpb25hbFdoaXRlc3BhY2VfLCBwYXJzZXIsIG9wdGlvbmFsV2hpdGVzcGFjZV8pO1xufVxuY29uc3QgaWRlbnRpZmllcl8gPSBwX19uYW1lc3BhY2UudG9rZW4oKHQpID0+IHQubmFtZSA9PT0gJ2lkbicgPyB0LnRleHQgOiB1bmRlZmluZWQpO1xuY29uc3QgaGFzaElkXyA9IHBfX25hbWVzcGFjZS50b2tlbigodCkgPT4gdC5uYW1lID09PSAnI2lkJyA/IHQudGV4dC5zbGljZSgxKSA6IHVuZGVmaW5lZCk7XG5jb25zdCBzdHJpbmdfID0gcF9fbmFtZXNwYWNlLnRva2VuKCh0KSA9PiB0Lm5hbWUuc3RhcnRzV2l0aCgnc3RyJykgPyB0LnRleHQuc2xpY2UoMSwgLTEpIDogdW5kZWZpbmVkKTtcbmNvbnN0IG5hbWVzcGFjZV8gPSBwX19uYW1lc3BhY2UubGVmdChwX19uYW1lc3BhY2Uub3B0aW9uKGlkZW50aWZpZXJfLCAnJyksIGxpdGVyYWwoJ3wnKSk7XG5jb25zdCBxdWFsaWZpZWROYW1lXyA9IHBfX25hbWVzcGFjZS5laXRoZXJPcihwX19uYW1lc3BhY2UuYWIobmFtZXNwYWNlXywgaWRlbnRpZmllcl8sIChucywgbmFtZSkgPT4gKHsgbmFtZTogbmFtZSwgbmFtZXNwYWNlOiBucyB9KSksIHBfX25hbWVzcGFjZS5tYXAoaWRlbnRpZmllcl8sIChuYW1lKSA9PiAoeyBuYW1lOiBuYW1lLCBuYW1lc3BhY2U6IG51bGwgfSkpKTtcbmNvbnN0IHVuaVNlbGVjdG9yXyA9IHBfX25hbWVzcGFjZS5laXRoZXJPcihwX19uYW1lc3BhY2UuYWIobmFtZXNwYWNlXywgbGl0ZXJhbCgnKicpLCAobnMpID0+ICh7IHR5cGU6ICd1bml2ZXJzYWwnLCBuYW1lc3BhY2U6IG5zLCBzcGVjaWZpY2l0eTogWzAsIDAsIDBdIH0pKSwgcF9fbmFtZXNwYWNlLm1hcChsaXRlcmFsKCcqJyksICgpID0+ICh7IHR5cGU6ICd1bml2ZXJzYWwnLCBuYW1lc3BhY2U6IG51bGwsIHNwZWNpZmljaXR5OiBbMCwgMCwgMF0gfSkpKTtcbmNvbnN0IHRhZ1NlbGVjdG9yXyA9IHBfX25hbWVzcGFjZS5tYXAocXVhbGlmaWVkTmFtZV8sICh7IG5hbWUsIG5hbWVzcGFjZSB9KSA9PiAoe1xuICAgIHR5cGU6ICd0YWcnLFxuICAgIG5hbWU6IG5hbWUsXG4gICAgbmFtZXNwYWNlOiBuYW1lc3BhY2UsXG4gICAgc3BlY2lmaWNpdHk6IFswLCAwLCAxXVxufSkpO1xuY29uc3QgY2xhc3NTZWxlY3Rvcl8gPSBwX19uYW1lc3BhY2UuYWIobGl0ZXJhbCgnLicpLCBpZGVudGlmaWVyXywgKGZ1bGxzdG9wLCBuYW1lKSA9PiAoe1xuICAgIHR5cGU6ICdjbGFzcycsXG4gICAgbmFtZTogbmFtZSxcbiAgICBzcGVjaWZpY2l0eTogWzAsIDEsIDBdXG59KSk7XG5jb25zdCBpZFNlbGVjdG9yXyA9IHBfX25hbWVzcGFjZS5tYXAoaGFzaElkXywgKG5hbWUpID0+ICh7XG4gICAgdHlwZTogJ2lkJyxcbiAgICBuYW1lOiBuYW1lLFxuICAgIHNwZWNpZmljaXR5OiBbMSwgMCwgMF1cbn0pKTtcbmNvbnN0IGF0dHJNb2RpZmllcl8gPSBwX19uYW1lc3BhY2UudG9rZW4oKHQpID0+IHtcbiAgICBpZiAodC5uYW1lID09PSAnaWRuJykge1xuICAgICAgICBpZiAodC50ZXh0ID09PSAnaScgfHwgdC50ZXh0ID09PSAnSScpIHtcbiAgICAgICAgICAgIHJldHVybiAnaSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHQudGV4dCA9PT0gJ3MnIHx8IHQudGV4dCA9PT0gJ1MnKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3MnO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59KTtcbmNvbnN0IGF0dHJWYWx1ZV8gPSBwX19uYW1lc3BhY2UuZWl0aGVyT3IocF9fbmFtZXNwYWNlLmFiKHN0cmluZ18sIHBfX25hbWVzcGFjZS5vcHRpb24ocF9fbmFtZXNwYWNlLnJpZ2h0KG9wdGlvbmFsV2hpdGVzcGFjZV8sIGF0dHJNb2RpZmllcl8pLCBudWxsKSwgKHYsIG1vZCkgPT4gKHsgdmFsdWU6IHYsIG1vZGlmaWVyOiBtb2QgfSkpLCBwX19uYW1lc3BhY2UuYWIoaWRlbnRpZmllcl8sIHBfX25hbWVzcGFjZS5vcHRpb24ocF9fbmFtZXNwYWNlLnJpZ2h0KHdoaXRlc3BhY2VfLCBhdHRyTW9kaWZpZXJfKSwgbnVsbCksICh2LCBtb2QpID0+ICh7IHZhbHVlOiB2LCBtb2RpZmllcjogbW9kIH0pKSk7XG5jb25zdCBhdHRyTWF0Y2hlcl8gPSBwX19uYW1lc3BhY2UuY2hvaWNlKHBfX25hbWVzcGFjZS5tYXAobGl0ZXJhbCgnPScpLCAoKSA9PiAnPScpLCBwX19uYW1lc3BhY2UuYWIobGl0ZXJhbCgnficpLCBsaXRlcmFsKCc9JyksICgpID0+ICd+PScpLCBwX19uYW1lc3BhY2UuYWIobGl0ZXJhbCgnfCcpLCBsaXRlcmFsKCc9JyksICgpID0+ICd8PScpLCBwX19uYW1lc3BhY2UuYWIobGl0ZXJhbCgnXicpLCBsaXRlcmFsKCc9JyksICgpID0+ICdePScpLCBwX19uYW1lc3BhY2UuYWIobGl0ZXJhbCgnJCcpLCBsaXRlcmFsKCc9JyksICgpID0+ICckPScpLCBwX19uYW1lc3BhY2UuYWIobGl0ZXJhbCgnKicpLCBsaXRlcmFsKCc9JyksICgpID0+ICcqPScpKTtcbmNvbnN0IGF0dHJQcmVzZW5jZVNlbGVjdG9yXyA9IHBfX25hbWVzcGFjZS5hYmMobGl0ZXJhbCgnWycpLCBvcHRpb25hbGx5U3BhY2VkKHF1YWxpZmllZE5hbWVfKSwgbGl0ZXJhbCgnXScpLCAobGJyLCB7IG5hbWUsIG5hbWVzcGFjZSB9KSA9PiAoe1xuICAgIHR5cGU6ICdhdHRyUHJlc2VuY2UnLFxuICAgIG5hbWU6IG5hbWUsXG4gICAgbmFtZXNwYWNlOiBuYW1lc3BhY2UsXG4gICAgc3BlY2lmaWNpdHk6IFswLCAxLCAwXVxufSkpO1xuY29uc3QgYXR0clZhbHVlU2VsZWN0b3JfID0gcF9fbmFtZXNwYWNlLm1pZGRsZShsaXRlcmFsKCdbJyksIHBfX25hbWVzcGFjZS5hYmMob3B0aW9uYWxseVNwYWNlZChxdWFsaWZpZWROYW1lXyksIGF0dHJNYXRjaGVyXywgb3B0aW9uYWxseVNwYWNlZChhdHRyVmFsdWVfKSwgKHsgbmFtZSwgbmFtZXNwYWNlIH0sIG1hdGNoZXIsIHsgdmFsdWUsIG1vZGlmaWVyIH0pID0+ICh7XG4gICAgdHlwZTogJ2F0dHJWYWx1ZScsXG4gICAgbmFtZTogbmFtZSxcbiAgICBuYW1lc3BhY2U6IG5hbWVzcGFjZSxcbiAgICBtYXRjaGVyOiBtYXRjaGVyLFxuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBtb2RpZmllcjogbW9kaWZpZXIsXG4gICAgc3BlY2lmaWNpdHk6IFswLCAxLCAwXVxufSkpLCBsaXRlcmFsKCddJykpO1xuY29uc3QgYXR0clNlbGVjdG9yXyA9IHBfX25hbWVzcGFjZS5laXRoZXJPcihhdHRyUHJlc2VuY2VTZWxlY3Rvcl8sIGF0dHJWYWx1ZVNlbGVjdG9yXyk7XG5jb25zdCB0eXBlU2VsZWN0b3JfID0gcF9fbmFtZXNwYWNlLmVpdGhlck9yKHVuaVNlbGVjdG9yXywgdGFnU2VsZWN0b3JfKTtcbmNvbnN0IHN1YmNsYXNzU2VsZWN0b3JfID0gcF9fbmFtZXNwYWNlLmNob2ljZShpZFNlbGVjdG9yXywgY2xhc3NTZWxlY3Rvcl8sIGF0dHJTZWxlY3Rvcl8pO1xuY29uc3QgY29tcG91bmRTZWxlY3Rvcl8gPSBwX19uYW1lc3BhY2UubWFwKHBfX25hbWVzcGFjZS5laXRoZXJPcihwX19uYW1lc3BhY2UuZmxhdHRlbih0eXBlU2VsZWN0b3JfLCBwX19uYW1lc3BhY2UubWFueShzdWJjbGFzc1NlbGVjdG9yXykpLCBwX19uYW1lc3BhY2UubWFueTEoc3ViY2xhc3NTZWxlY3Rvcl8pKSwgKHNzKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2NvbXBvdW5kJyxcbiAgICAgICAgbGlzdDogc3MsXG4gICAgICAgIHNwZWNpZmljaXR5OiBzdW1BbGxTcGVjKHNzLm1hcChzID0+IHMuc3BlY2lmaWNpdHkpKVxuICAgIH07XG59KTtcbmNvbnN0IGNvbWJpbmF0b3JfID0gcF9fbmFtZXNwYWNlLmNob2ljZShwX19uYW1lc3BhY2UubWFwKGxpdGVyYWwoJz4nKSwgKCkgPT4gJz4nKSwgcF9fbmFtZXNwYWNlLm1hcChsaXRlcmFsKCcrJyksICgpID0+ICcrJyksIHBfX25hbWVzcGFjZS5tYXAobGl0ZXJhbCgnficpLCAoKSA9PiAnficpLCBwX19uYW1lc3BhY2UuYWIobGl0ZXJhbCgnfCcpLCBsaXRlcmFsKCd8JyksICgpID0+ICd8fCcpKTtcbmNvbnN0IGNvbWJpbmF0b3JTZXBhcmF0b3JfID0gcF9fbmFtZXNwYWNlLmVpdGhlck9yKG9wdGlvbmFsbHlTcGFjZWQoY29tYmluYXRvcl8pLCBwX19uYW1lc3BhY2UubWFwKHdoaXRlc3BhY2VfLCAoKSA9PiAnICcpKTtcbmNvbnN0IGNvbXBsZXhTZWxlY3Rvcl8gPSBwX19uYW1lc3BhY2UubGVmdEFzc29jMihjb21wb3VuZFNlbGVjdG9yXywgcF9fbmFtZXNwYWNlLm1hcChjb21iaW5hdG9yU2VwYXJhdG9yXywgKGMpID0+IChsZWZ0LCByaWdodCkgPT4gKHtcbiAgICB0eXBlOiAnY29tcG91bmQnLFxuICAgIGxpc3Q6IFsuLi5yaWdodC5saXN0LCB7IHR5cGU6ICdjb21iaW5hdG9yJywgY29tYmluYXRvcjogYywgbGVmdDogbGVmdCwgc3BlY2lmaWNpdHk6IGxlZnQuc3BlY2lmaWNpdHkgfV0sXG4gICAgc3BlY2lmaWNpdHk6IHN1bVNwZWMobGVmdC5zcGVjaWZpY2l0eSwgcmlnaHQuc3BlY2lmaWNpdHkpXG59KSksIGNvbXBvdW5kU2VsZWN0b3JfKTtcbmNvbnN0IGxpc3RTZWxlY3Rvcl8gPSBwX19uYW1lc3BhY2UubGVmdEFzc29jMihwX19uYW1lc3BhY2UubWFwKGNvbXBsZXhTZWxlY3Rvcl8sIChzKSA9PiAoeyB0eXBlOiAnbGlzdCcsIGxpc3Q6IFtzXSB9KSksIHBfX25hbWVzcGFjZS5tYXAob3B0aW9uYWxseVNwYWNlZChsaXRlcmFsKCcsJykpLCAoKSA9PiAoYWNjLCBuZXh0KSA9PiAoeyB0eXBlOiAnbGlzdCcsIGxpc3Q6IFsuLi5hY2MubGlzdCwgbmV4dF0gfSkpLCBjb21wbGV4U2VsZWN0b3JfKTtcbmZ1bmN0aW9uIHBhcnNlXyhwYXJzZXIsIHN0cikge1xuICAgIGNvbnN0IGxleGVyUmVzdWx0ID0gbGV4KHN0cik7XG4gICAgaWYgKCFsZXhlclJlc3VsdC5jb21wbGV0ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBpbnB1dCBcIiR7c3RyfVwiIHdhcyBvbmx5IHBhcnRpYWxseSB0b2tlbml6ZWQsIHN0b3BwZWQgYXQgb2Zmc2V0ICR7bGV4ZXJSZXN1bHQub2Zmc2V0fSFcXG5gICtcbiAgICAgICAgICAgIHByZXR0eVByaW50UG9zaXRpb24oc3RyLCBsZXhlclJlc3VsdC5vZmZzZXQpKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gb3B0aW9uYWxseVNwYWNlZChwYXJzZXIpKHsgdG9rZW5zOiBsZXhlclJlc3VsdC50b2tlbnMsIG9wdGlvbnM6IHVuZGVmaW5lZCB9LCAwKTtcbiAgICBpZiAoIXJlc3VsdC5tYXRjaGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gbWF0Y2ggZm9yIFwiJHtzdHJ9XCIgaW5wdXQhYCk7XG4gICAgfVxuICAgIGlmIChyZXN1bHQucG9zaXRpb24gPCBsZXhlclJlc3VsdC50b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHRva2VuID0gbGV4ZXJSZXN1bHQudG9rZW5zW3Jlc3VsdC5wb3NpdGlvbl07XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGlucHV0IFwiJHtzdHJ9XCIgd2FzIG9ubHkgcGFydGlhbGx5IHBhcnNlZCwgc3RvcHBlZCBhdCBvZmZzZXQgJHt0b2tlbi5vZmZzZXR9IVxcbmAgK1xuICAgICAgICAgICAgcHJldHR5UHJpbnRQb3NpdGlvbihzdHIsIHRva2VuLm9mZnNldCwgdG9rZW4ubGVuKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQudmFsdWU7XG59XG5mdW5jdGlvbiBwcmV0dHlQcmludFBvc2l0aW9uKHN0ciwgb2Zmc2V0LCBsZW4gPSAxKSB7XG4gICAgcmV0dXJuIGAke3N0ci5yZXBsYWNlKC8oXFx0KXwoXFxyKXwoXFxuKS9nLCAobSwgdCwgcikgPT4gdCA/ICdcXHUyNDA5JyA6IHIgPyAnXFx1MjQwZCcgOiAnXFx1MjQwYScpfVxcbiR7JycucGFkRW5kKG9mZnNldCl9JHsnXicucmVwZWF0KGxlbil9YDtcbn1cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICAgIHJldHVybiBwYXJzZV8obGlzdFNlbGVjdG9yXywgc3RyKTtcbn1cbmZ1bmN0aW9uIHBhcnNlMShzdHIpIHtcbiAgICByZXR1cm4gcGFyc2VfKGNvbXBsZXhTZWxlY3Rvcl8sIHN0cik7XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZShzZWxlY3Rvcikge1xuICAgIGlmICghc2VsZWN0b3IudHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgaXMgbm90IGFuIEFTVCBub2RlLicpO1xuICAgIH1cbiAgICBzd2l0Y2ggKHNlbGVjdG9yLnR5cGUpIHtcbiAgICAgICAgY2FzZSAndW5pdmVyc2FsJzpcbiAgICAgICAgICAgIHJldHVybiBfc2VyTnMoc2VsZWN0b3IubmFtZXNwYWNlKSArICcqJztcbiAgICAgICAgY2FzZSAndGFnJzpcbiAgICAgICAgICAgIHJldHVybiBfc2VyTnMoc2VsZWN0b3IubmFtZXNwYWNlKSArIHNlbGVjdG9yLm5hbWU7XG4gICAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgICAgIHJldHVybiAnLicgKyBzZWxlY3Rvci5uYW1lO1xuICAgICAgICBjYXNlICdpZCc6XG4gICAgICAgICAgICByZXR1cm4gJyMnICsgc2VsZWN0b3IubmFtZTtcbiAgICAgICAgY2FzZSAnYXR0clByZXNlbmNlJzpcbiAgICAgICAgICAgIHJldHVybiBgWyR7X3Nlck5zKHNlbGVjdG9yLm5hbWVzcGFjZSl9JHtzZWxlY3Rvci5uYW1lfV1gO1xuICAgICAgICBjYXNlICdhdHRyVmFsdWUnOlxuICAgICAgICAgICAgcmV0dXJuIGBbJHtfc2VyTnMoc2VsZWN0b3IubmFtZXNwYWNlKX0ke3NlbGVjdG9yLm5hbWV9JHtzZWxlY3Rvci5tYXRjaGVyfSR7X3NlclN0cihzZWxlY3Rvci52YWx1ZSl9JHsoc2VsZWN0b3IubW9kaWZpZXIgPyBzZWxlY3Rvci5tb2RpZmllciA6ICcnKX1dYDtcbiAgICAgICAgY2FzZSAnY29tYmluYXRvcic6XG4gICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplKHNlbGVjdG9yLmxlZnQpICsgc2VsZWN0b3IuY29tYmluYXRvcjtcbiAgICAgICAgY2FzZSAnY29tcG91bmQnOlxuICAgICAgICAgICAgcmV0dXJuIHNlbGVjdG9yLmxpc3QucmVkdWNlKChhY2MsIG5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSAnY29tYmluYXRvcicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZShub2RlKSArIGFjYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhY2MgKyBzZXJpYWxpemUobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgJycpO1xuICAgICAgICBjYXNlICdsaXN0JzpcbiAgICAgICAgICAgIHJldHVybiBzZWxlY3Rvci5saXN0Lm1hcChzZXJpYWxpemUpLmpvaW4oJywnKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfc2VyTnMobnMpIHtcbiAgICByZXR1cm4gKG5zIHx8IG5zID09PSAnJylcbiAgICAgICAgPyBucyArICd8J1xuICAgICAgICA6ICcnO1xufVxuZnVuY3Rpb24gX3NlclN0cihzdHIpIHtcbiAgICBpZiAoc3RyLmluZGV4T2YoJ1wiJykgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBgXCIke3N0cn1cImA7XG4gICAgfVxuICAgIGVsc2UgaWYgKHN0ci5pbmRleE9mKFwiJ1wiKSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIGAnJHtzdHJ9J2A7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gYFwiJHtzdHIucmVwbGFjZSgnXCInLCAnXFxcXFwiJyl9XCJgO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZShzZWxlY3Rvcikge1xuICAgIGlmICghc2VsZWN0b3IudHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgaXMgbm90IGFuIEFTVCBub2RlLicpO1xuICAgIH1cbiAgICBzd2l0Y2ggKHNlbGVjdG9yLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnY29tcG91bmQnOiB7XG4gICAgICAgICAgICBzZWxlY3Rvci5saXN0LmZvckVhY2gobm9ybWFsaXplKTtcbiAgICAgICAgICAgIHNlbGVjdG9yLmxpc3Quc29ydCgoYSwgYikgPT4gX2NvbXBhcmVBcnJheXMoX2dldFNlbGVjdG9yUHJpb3JpdHkoYSksIF9nZXRTZWxlY3RvclByaW9yaXR5KGIpKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdjb21iaW5hdG9yJzoge1xuICAgICAgICAgICAgbm9ybWFsaXplKHNlbGVjdG9yLmxlZnQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnbGlzdCc6IHtcbiAgICAgICAgICAgIHNlbGVjdG9yLmxpc3QuZm9yRWFjaChub3JtYWxpemUpO1xuICAgICAgICAgICAgc2VsZWN0b3IubGlzdC5zb3J0KChhLCBiKSA9PiAoc2VyaWFsaXplKGEpIDwgc2VyaWFsaXplKGIpKSA/IC0xIDogMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0b3I7XG59XG5mdW5jdGlvbiBfZ2V0U2VsZWN0b3JQcmlvcml0eShzZWxlY3Rvcikge1xuICAgIHN3aXRjaCAoc2VsZWN0b3IudHlwZSkge1xuICAgICAgICBjYXNlICd1bml2ZXJzYWwnOlxuICAgICAgICAgICAgcmV0dXJuIFsxXTtcbiAgICAgICAgY2FzZSAndGFnJzpcbiAgICAgICAgICAgIHJldHVybiBbMV07XG4gICAgICAgIGNhc2UgJ2lkJzpcbiAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgICAgIHJldHVybiBbMywgc2VsZWN0b3IubmFtZV07XG4gICAgICAgIGNhc2UgJ2F0dHJQcmVzZW5jZSc6XG4gICAgICAgICAgICByZXR1cm4gWzQsIHNlcmlhbGl6ZShzZWxlY3RvcildO1xuICAgICAgICBjYXNlICdhdHRyVmFsdWUnOlxuICAgICAgICAgICAgcmV0dXJuIFs1LCBzZXJpYWxpemUoc2VsZWN0b3IpXTtcbiAgICAgICAgY2FzZSAnY29tYmluYXRvcic6XG4gICAgICAgICAgICByZXR1cm4gWzE1LCBzZXJpYWxpemUoc2VsZWN0b3IpXTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb21wYXJlU2VsZWN0b3JzKGEsIGIpIHtcbiAgICByZXR1cm4gX2NvbXBhcmVBcnJheXMoYS5zcGVjaWZpY2l0eSwgYi5zcGVjaWZpY2l0eSk7XG59XG5mdW5jdGlvbiBjb21wYXJlU3BlY2lmaWNpdHkoYSwgYikge1xuICAgIHJldHVybiBfY29tcGFyZUFycmF5cyhhLCBiKTtcbn1cbmZ1bmN0aW9uIF9jb21wYXJlQXJyYXlzKGEsIGIpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYSkgfHwgIUFycmF5LmlzQXJyYXkoYikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBhcnJheXMuJyk7XG4gICAgfVxuICAgIGNvbnN0IHNob3J0ZXIgPSAoYS5sZW5ndGggPCBiLmxlbmd0aCkgPyBhLmxlbmd0aCA6IGIubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2hvcnRlcjsgaSsrKSB7XG4gICAgICAgIGlmIChhW2ldID09PSBiW2ldKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGFbaV0gPCBiW2ldKSA/IC0xIDogMTtcbiAgICB9XG4gICAgcmV0dXJuIGEubGVuZ3RoIC0gYi5sZW5ndGg7XG59XG5cbmV4cG9ydHMuQXN0ID0gYXN0O1xuZXhwb3J0cy5jb21wYXJlU2VsZWN0b3JzID0gY29tcGFyZVNlbGVjdG9ycztcbmV4cG9ydHMuY29tcGFyZVNwZWNpZmljaXR5ID0gY29tcGFyZVNwZWNpZmljaXR5O1xuZXhwb3J0cy5ub3JtYWxpemUgPSBub3JtYWxpemU7XG5leHBvcnRzLnBhcnNlID0gcGFyc2U7XG5leHBvcnRzLnBhcnNlMSA9IHBhcnNlMTtcbmV4cG9ydHMuc2VyaWFsaXplID0gc2VyaWFsaXplO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibGVhYyIsInJlcXVpcmUiLCJwIiwiX2ludGVyb3BOYW1lc3BhY2UiLCJlIiwiX19lc01vZHVsZSIsIm4iLCJjcmVhdGUiLCJrZXlzIiwiZm9yRWFjaCIsImsiLCJkIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0IiwiZW51bWVyYWJsZSIsImZyZWV6ZSIsInBfX25hbWVzcGFjZSIsImFzdCIsIl9fcHJvdG9fXyIsImxleCIsImNyZWF0ZUxleGVyIiwibmFtZSIsInJlZ2V4Iiwic3VtU3BlYyIsImEwIiwiYTEiLCJhMiIsImIwIiwiYjEiLCJiMiIsInN1bUFsbFNwZWMiLCJzcyIsInJlZHVjZSIsImxpdGVyYWwiLCJ0b2tlbiIsInQiLCJ1bmRlZmluZWQiLCJ3aGl0ZXNwYWNlXyIsIm9wdGlvbmFsV2hpdGVzcGFjZV8iLCJvcHRpb24iLCJvcHRpb25hbGx5U3BhY2VkIiwicGFyc2VyIiwibWlkZGxlIiwiaWRlbnRpZmllcl8iLCJ0ZXh0IiwiaGFzaElkXyIsInNsaWNlIiwic3RyaW5nXyIsInN0YXJ0c1dpdGgiLCJuYW1lc3BhY2VfIiwibGVmdCIsInF1YWxpZmllZE5hbWVfIiwiZWl0aGVyT3IiLCJhYiIsIm5zIiwibmFtZXNwYWNlIiwibWFwIiwidW5pU2VsZWN0b3JfIiwidHlwZSIsInNwZWNpZmljaXR5IiwidGFnU2VsZWN0b3JfIiwiY2xhc3NTZWxlY3Rvcl8iLCJmdWxsc3RvcCIsImlkU2VsZWN0b3JfIiwiYXR0ck1vZGlmaWVyXyIsImF0dHJWYWx1ZV8iLCJyaWdodCIsInYiLCJtb2QiLCJtb2RpZmllciIsImF0dHJNYXRjaGVyXyIsImNob2ljZSIsImF0dHJQcmVzZW5jZVNlbGVjdG9yXyIsImFiYyIsImxiciIsImF0dHJWYWx1ZVNlbGVjdG9yXyIsIm1hdGNoZXIiLCJhdHRyU2VsZWN0b3JfIiwidHlwZVNlbGVjdG9yXyIsInN1YmNsYXNzU2VsZWN0b3JfIiwiY29tcG91bmRTZWxlY3Rvcl8iLCJmbGF0dGVuIiwibWFueSIsIm1hbnkxIiwibGlzdCIsInMiLCJjb21iaW5hdG9yXyIsImNvbWJpbmF0b3JTZXBhcmF0b3JfIiwiY29tcGxleFNlbGVjdG9yXyIsImxlZnRBc3NvYzIiLCJjIiwiY29tYmluYXRvciIsImxpc3RTZWxlY3Rvcl8iLCJhY2MiLCJuZXh0IiwicGFyc2VfIiwic3RyIiwibGV4ZXJSZXN1bHQiLCJjb21wbGV0ZSIsIkVycm9yIiwib2Zmc2V0IiwicHJldHR5UHJpbnRQb3NpdGlvbiIsInJlc3VsdCIsInRva2VucyIsIm9wdGlvbnMiLCJtYXRjaGVkIiwicG9zaXRpb24iLCJsZW5ndGgiLCJsZW4iLCJyZXBsYWNlIiwibSIsInIiLCJwYWRFbmQiLCJyZXBlYXQiLCJwYXJzZSIsInBhcnNlMSIsInNlcmlhbGl6ZSIsInNlbGVjdG9yIiwiX3Nlck5zIiwiX3NlclN0ciIsIm5vZGUiLCJqb2luIiwiaW5kZXhPZiIsIm5vcm1hbGl6ZSIsInNvcnQiLCJhIiwiYiIsIl9jb21wYXJlQXJyYXlzIiwiX2dldFNlbGVjdG9yUHJpb3JpdHkiLCJjb21wYXJlU2VsZWN0b3JzIiwiY29tcGFyZVNwZWNpZmljaXR5IiwiQXJyYXkiLCJpc0FycmF5Iiwic2hvcnRlciIsImkiLCJBc3QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/parseley/lib/parseley.cjs\n");

/***/ }),

/***/ "(rsc)/../node_modules/parseley/lib/parseley.cjs":
/*!*************************************************!*\
  !*** ../node_modules/parseley/lib/parseley.cjs ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar leac = __webpack_require__(/*! leac */ \"(rsc)/../node_modules/leac/lib/leac.cjs\");\nvar p = __webpack_require__(/*! peberminta */ \"(rsc)/../node_modules/peberminta/lib/core.cjs\");\nfunction _interopNamespace(e) {\n    if (e && e.__esModule) return e;\n    var n = Object.create(null);\n    if (e) {\n        Object.keys(e).forEach(function(k) {\n            if (k !== \"default\") {\n                var d = Object.getOwnPropertyDescriptor(e, k);\n                Object.defineProperty(n, k, d.get ? d : {\n                    enumerable: true,\n                    get: function() {\n                        return e[k];\n                    }\n                });\n            }\n        });\n    }\n    n[\"default\"] = e;\n    return Object.freeze(n);\n}\nvar p__namespace = /*#__PURE__*/ _interopNamespace(p);\nvar ast = /*#__PURE__*/ Object.freeze({\n    __proto__: null\n});\nconst lex = leac.createLexer([\n    {\n        name: \"ws\",\n        regex: /[ \\t\\r\\n\\f]+/\n    },\n    {\n        name: \"idn\",\n        regex: /[a-zA-Z_-][a-zA-Z0-9_-]*/\n    },\n    {\n        name: \"#id\",\n        regex: /#[a-zA-Z0-9_-]+/\n    },\n    {\n        name: \"str1\",\n        regex: /'(?:\\\\['\\\\]|[^\\n'\\\\])*'/\n    },\n    {\n        name: \"str2\",\n        regex: /\"(?:\\\\[\"\\\\]|[^\\n\"\\\\])*\"/\n    },\n    {\n        name: \"*\"\n    },\n    {\n        name: \".\"\n    },\n    {\n        name: \",\"\n    },\n    {\n        name: \"[\"\n    },\n    {\n        name: \"]\"\n    },\n    {\n        name: \"=\"\n    },\n    {\n        name: \">\"\n    },\n    {\n        name: \"|\"\n    },\n    {\n        name: \"+\"\n    },\n    {\n        name: \"~\"\n    },\n    {\n        name: \"^\"\n    },\n    {\n        name: \"$\"\n    }\n]);\nfunction sumSpec([a0, a1, a2], [b0, b1, b2]) {\n    return [\n        a0 + b0,\n        a1 + b1,\n        a2 + b2\n    ];\n}\nfunction sumAllSpec(ss) {\n    return ss.reduce(sumSpec, [\n        0,\n        0,\n        0\n    ]);\n}\nfunction literal(name) {\n    return p__namespace.token((t)=>t.name === name ? true : undefined);\n}\nconst whitespace_ = p__namespace.token((t)=>t.name === \"ws\" ? null : undefined);\nconst optionalWhitespace_ = p__namespace.option(whitespace_, null);\nfunction optionallySpaced(parser) {\n    return p__namespace.middle(optionalWhitespace_, parser, optionalWhitespace_);\n}\nconst identifier_ = p__namespace.token((t)=>t.name === \"idn\" ? t.text : undefined);\nconst hashId_ = p__namespace.token((t)=>t.name === \"#id\" ? t.text.slice(1) : undefined);\nconst string_ = p__namespace.token((t)=>t.name.startsWith(\"str\") ? t.text.slice(1, -1) : undefined);\nconst namespace_ = p__namespace.left(p__namespace.option(identifier_, \"\"), literal(\"|\"));\nconst qualifiedName_ = p__namespace.eitherOr(p__namespace.ab(namespace_, identifier_, (ns, name)=>({\n        name: name,\n        namespace: ns\n    })), p__namespace.map(identifier_, (name)=>({\n        name: name,\n        namespace: null\n    })));\nconst uniSelector_ = p__namespace.eitherOr(p__namespace.ab(namespace_, literal(\"*\"), (ns)=>({\n        type: \"universal\",\n        namespace: ns,\n        specificity: [\n            0,\n            0,\n            0\n        ]\n    })), p__namespace.map(literal(\"*\"), ()=>({\n        type: \"universal\",\n        namespace: null,\n        specificity: [\n            0,\n            0,\n            0\n        ]\n    })));\nconst tagSelector_ = p__namespace.map(qualifiedName_, ({ name, namespace })=>({\n        type: \"tag\",\n        name: name,\n        namespace: namespace,\n        specificity: [\n            0,\n            0,\n            1\n        ]\n    }));\nconst classSelector_ = p__namespace.ab(literal(\".\"), identifier_, (fullstop, name)=>({\n        type: \"class\",\n        name: name,\n        specificity: [\n            0,\n            1,\n            0\n        ]\n    }));\nconst idSelector_ = p__namespace.map(hashId_, (name)=>({\n        type: \"id\",\n        name: name,\n        specificity: [\n            1,\n            0,\n            0\n        ]\n    }));\nconst attrModifier_ = p__namespace.token((t)=>{\n    if (t.name === \"idn\") {\n        if (t.text === \"i\" || t.text === \"I\") {\n            return \"i\";\n        }\n        if (t.text === \"s\" || t.text === \"S\") {\n            return \"s\";\n        }\n    }\n    return undefined;\n});\nconst attrValue_ = p__namespace.eitherOr(p__namespace.ab(string_, p__namespace.option(p__namespace.right(optionalWhitespace_, attrModifier_), null), (v, mod)=>({\n        value: v,\n        modifier: mod\n    })), p__namespace.ab(identifier_, p__namespace.option(p__namespace.right(whitespace_, attrModifier_), null), (v, mod)=>({\n        value: v,\n        modifier: mod\n    })));\nconst attrMatcher_ = p__namespace.choice(p__namespace.map(literal(\"=\"), ()=>\"=\"), p__namespace.ab(literal(\"~\"), literal(\"=\"), ()=>\"~=\"), p__namespace.ab(literal(\"|\"), literal(\"=\"), ()=>\"|=\"), p__namespace.ab(literal(\"^\"), literal(\"=\"), ()=>\"^=\"), p__namespace.ab(literal(\"$\"), literal(\"=\"), ()=>\"$=\"), p__namespace.ab(literal(\"*\"), literal(\"=\"), ()=>\"*=\"));\nconst attrPresenceSelector_ = p__namespace.abc(literal(\"[\"), optionallySpaced(qualifiedName_), literal(\"]\"), (lbr, { name, namespace })=>({\n        type: \"attrPresence\",\n        name: name,\n        namespace: namespace,\n        specificity: [\n            0,\n            1,\n            0\n        ]\n    }));\nconst attrValueSelector_ = p__namespace.middle(literal(\"[\"), p__namespace.abc(optionallySpaced(qualifiedName_), attrMatcher_, optionallySpaced(attrValue_), ({ name, namespace }, matcher, { value, modifier })=>({\n        type: \"attrValue\",\n        name: name,\n        namespace: namespace,\n        matcher: matcher,\n        value: value,\n        modifier: modifier,\n        specificity: [\n            0,\n            1,\n            0\n        ]\n    })), literal(\"]\"));\nconst attrSelector_ = p__namespace.eitherOr(attrPresenceSelector_, attrValueSelector_);\nconst typeSelector_ = p__namespace.eitherOr(uniSelector_, tagSelector_);\nconst subclassSelector_ = p__namespace.choice(idSelector_, classSelector_, attrSelector_);\nconst compoundSelector_ = p__namespace.map(p__namespace.eitherOr(p__namespace.flatten(typeSelector_, p__namespace.many(subclassSelector_)), p__namespace.many1(subclassSelector_)), (ss)=>{\n    return {\n        type: \"compound\",\n        list: ss,\n        specificity: sumAllSpec(ss.map((s)=>s.specificity))\n    };\n});\nconst combinator_ = p__namespace.choice(p__namespace.map(literal(\">\"), ()=>\">\"), p__namespace.map(literal(\"+\"), ()=>\"+\"), p__namespace.map(literal(\"~\"), ()=>\"~\"), p__namespace.ab(literal(\"|\"), literal(\"|\"), ()=>\"||\"));\nconst combinatorSeparator_ = p__namespace.eitherOr(optionallySpaced(combinator_), p__namespace.map(whitespace_, ()=>\" \"));\nconst complexSelector_ = p__namespace.leftAssoc2(compoundSelector_, p__namespace.map(combinatorSeparator_, (c)=>(left, right)=>({\n            type: \"compound\",\n            list: [\n                ...right.list,\n                {\n                    type: \"combinator\",\n                    combinator: c,\n                    left: left,\n                    specificity: left.specificity\n                }\n            ],\n            specificity: sumSpec(left.specificity, right.specificity)\n        })), compoundSelector_);\nconst listSelector_ = p__namespace.leftAssoc2(p__namespace.map(complexSelector_, (s)=>({\n        type: \"list\",\n        list: [\n            s\n        ]\n    })), p__namespace.map(optionallySpaced(literal(\",\")), ()=>(acc, next)=>({\n            type: \"list\",\n            list: [\n                ...acc.list,\n                next\n            ]\n        })), complexSelector_);\nfunction parse_(parser, str) {\n    const lexerResult = lex(str);\n    if (!lexerResult.complete) {\n        throw new Error(`The input \"${str}\" was only partially tokenized, stopped at offset ${lexerResult.offset}!\\n` + prettyPrintPosition(str, lexerResult.offset));\n    }\n    const result = optionallySpaced(parser)({\n        tokens: lexerResult.tokens,\n        options: undefined\n    }, 0);\n    if (!result.matched) {\n        throw new Error(`No match for \"${str}\" input!`);\n    }\n    if (result.position < lexerResult.tokens.length) {\n        const token = lexerResult.tokens[result.position];\n        throw new Error(`The input \"${str}\" was only partially parsed, stopped at offset ${token.offset}!\\n` + prettyPrintPosition(str, token.offset, token.len));\n    }\n    return result.value;\n}\nfunction prettyPrintPosition(str, offset, len = 1) {\n    return `${str.replace(/(\\t)|(\\r)|(\\n)/g, (m, t, r)=>t ? \"␉\" : r ? \"␍\" : \"␊\")}\\n${\"\".padEnd(offset)}${\"^\".repeat(len)}`;\n}\nfunction parse(str) {\n    return parse_(listSelector_, str);\n}\nfunction parse1(str) {\n    return parse_(complexSelector_, str);\n}\nfunction serialize(selector) {\n    if (!selector.type) {\n        throw new Error(\"This is not an AST node.\");\n    }\n    switch(selector.type){\n        case \"universal\":\n            return _serNs(selector.namespace) + \"*\";\n        case \"tag\":\n            return _serNs(selector.namespace) + selector.name;\n        case \"class\":\n            return \".\" + selector.name;\n        case \"id\":\n            return \"#\" + selector.name;\n        case \"attrPresence\":\n            return `[${_serNs(selector.namespace)}${selector.name}]`;\n        case \"attrValue\":\n            return `[${_serNs(selector.namespace)}${selector.name}${selector.matcher}${_serStr(selector.value)}${selector.modifier ? selector.modifier : \"\"}]`;\n        case \"combinator\":\n            return serialize(selector.left) + selector.combinator;\n        case \"compound\":\n            return selector.list.reduce((acc, node)=>{\n                if (node.type === \"combinator\") {\n                    return serialize(node) + acc;\n                } else {\n                    return acc + serialize(node);\n                }\n            }, \"\");\n        case \"list\":\n            return selector.list.map(serialize).join(\",\");\n    }\n}\nfunction _serNs(ns) {\n    return ns || ns === \"\" ? ns + \"|\" : \"\";\n}\nfunction _serStr(str) {\n    if (str.indexOf('\"') === -1) {\n        return `\"${str}\"`;\n    } else if (str.indexOf(\"'\") === -1) {\n        return `'${str}'`;\n    } else {\n        return `\"${str.replace('\"', '\\\\\"')}\"`;\n    }\n}\nfunction normalize(selector) {\n    if (!selector.type) {\n        throw new Error(\"This is not an AST node.\");\n    }\n    switch(selector.type){\n        case \"compound\":\n            {\n                selector.list.forEach(normalize);\n                selector.list.sort((a, b)=>_compareArrays(_getSelectorPriority(a), _getSelectorPriority(b)));\n                break;\n            }\n        case \"combinator\":\n            {\n                normalize(selector.left);\n                break;\n            }\n        case \"list\":\n            {\n                selector.list.forEach(normalize);\n                selector.list.sort((a, b)=>serialize(a) < serialize(b) ? -1 : 1);\n                break;\n            }\n    }\n    return selector;\n}\nfunction _getSelectorPriority(selector) {\n    switch(selector.type){\n        case \"universal\":\n            return [\n                1\n            ];\n        case \"tag\":\n            return [\n                1\n            ];\n        case \"id\":\n            return [\n                2\n            ];\n        case \"class\":\n            return [\n                3,\n                selector.name\n            ];\n        case \"attrPresence\":\n            return [\n                4,\n                serialize(selector)\n            ];\n        case \"attrValue\":\n            return [\n                5,\n                serialize(selector)\n            ];\n        case \"combinator\":\n            return [\n                15,\n                serialize(selector)\n            ];\n    }\n}\nfunction compareSelectors(a, b) {\n    return _compareArrays(a.specificity, b.specificity);\n}\nfunction compareSpecificity(a, b) {\n    return _compareArrays(a, b);\n}\nfunction _compareArrays(a, b) {\n    if (!Array.isArray(a) || !Array.isArray(b)) {\n        throw new Error(\"Arguments must be arrays.\");\n    }\n    const shorter = a.length < b.length ? a.length : b.length;\n    for(let i = 0; i < shorter; i++){\n        if (a[i] === b[i]) {\n            continue;\n        }\n        return a[i] < b[i] ? -1 : 1;\n    }\n    return a.length - b.length;\n}\nexports.Ast = ast;\nexports.compareSelectors = compareSelectors;\nexports.compareSpecificity = compareSpecificity;\nexports.normalize = normalize;\nexports.parse = parse;\nexports.parse1 = parse1;\nexports.serialize = serialize;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL3BhcnNlbGV5L2xpYi9wYXJzZWxleS5janMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQUEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFFN0QsSUFBSUMsT0FBT0MsbUJBQU9BLENBQUM7QUFDbkIsSUFBSUMsSUFBSUQsbUJBQU9BLENBQUM7QUFFaEIsU0FBU0Usa0JBQWtCQyxDQUFDO0lBQ3hCLElBQUlBLEtBQUtBLEVBQUVDLFVBQVUsRUFBRSxPQUFPRDtJQUM5QixJQUFJRSxJQUFJVixPQUFPVyxNQUFNLENBQUM7SUFDdEIsSUFBSUgsR0FBRztRQUNIUixPQUFPWSxJQUFJLENBQUNKLEdBQUdLLE9BQU8sQ0FBQyxTQUFVQyxDQUFDO1lBQzlCLElBQUlBLE1BQU0sV0FBVztnQkFDakIsSUFBSUMsSUFBSWYsT0FBT2dCLHdCQUF3QixDQUFDUixHQUFHTTtnQkFDM0NkLE9BQU9DLGNBQWMsQ0FBQ1MsR0FBR0ksR0FBR0MsRUFBRUUsR0FBRyxHQUFHRixJQUFJO29CQUNwQ0csWUFBWTtvQkFDWkQsS0FBSzt3QkFBYyxPQUFPVCxDQUFDLENBQUNNLEVBQUU7b0JBQUU7Z0JBQ3BDO1lBQ0o7UUFDSjtJQUNKO0lBQ0FKLENBQUMsQ0FBQyxVQUFVLEdBQUdGO0lBQ2YsT0FBT1IsT0FBT21CLE1BQU0sQ0FBQ1Q7QUFDekI7QUFFQSxJQUFJVSxlQUFlLFdBQVcsR0FBRWIsa0JBQWtCRDtBQUVsRCxJQUFJZSxNQUFNLFdBQVcsR0FBRXJCLE9BQU9tQixNQUFNLENBQUM7SUFDakNHLFdBQVc7QUFDZjtBQUVBLE1BQU1DLE1BQU1uQixLQUFLb0IsV0FBVyxDQUFDO0lBQ3pCO1FBQUVDLE1BQU07UUFBTUMsT0FBTztJQUFlO0lBQ3BDO1FBQUVELE1BQU07UUFBT0MsT0FBTztJQUEyQjtJQUNqRDtRQUFFRCxNQUFNO1FBQU9DLE9BQU87SUFBa0I7SUFDeEM7UUFBRUQsTUFBTTtRQUFRQyxPQUFPO0lBQTBCO0lBQ2pEO1FBQUVE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QUkyQixJQUFJLEdBQUdBLElBQUlELFNBQVNDLElBQUs7UUFDOUIsSUFBSVQsQ0FBQyxDQUFDUyxFQUFFLEtBQUtSLENBQUMsQ0FBQ1EsRUFBRSxFQUFFO1lBQ2Y7UUFDSjtRQUNBLE9BQU8sQ0FBRSxDQUFDQSxFQUFFLEdBQUdSLENBQUMsQ0FBQ1EsRUFBRSxHQUFJLENBQUMsSUFBSTtJQUNoQztJQUNBLE9BQU9ULEVBQUVsQixNQUFNLEdBQUdtQixFQUFFbkIsTUFBTTtBQUM5QjtBQUVBN0csV0FBVyxHQUFHbUI7QUFDZG5CLHdCQUF3QixHQUFHbUk7QUFDM0JuSSwwQkFBMEIsR0FBR29JO0FBQzdCcEksaUJBQWlCLEdBQUc2SDtBQUNwQjdILGFBQWEsR0FBR29IO0FBQ2hCcEgsY0FBYyxHQUFHcUg7QUFDakJySCxpQkFBaUIsR0FBR3NIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtZW1haWwtY2xpZW50Ly4uL25vZGVfbW9kdWxlcy9wYXJzZWxleS9saWIvcGFyc2VsZXkuY2pzPzQ3MzEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgbGVhYyA9IHJlcXVpcmUoJ2xlYWMnKTtcbnZhciBwID0gcmVxdWlyZSgncGViZXJtaW50YScpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcE5hbWVzcGFjZShlKSB7XG4gICAgaWYgKGUgJiYgZS5fX2VzTW9kdWxlKSByZXR1cm4gZTtcbiAgICB2YXIgbiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgaWYgKGUpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoZSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgaWYgKGsgIT09ICdkZWZhdWx0Jykge1xuICAgICAgICAgICAgICAgIHZhciBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBrKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgaywgZC5nZXQgPyBkIDoge1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVba107IH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5bXCJkZWZhdWx0XCJdID0gZTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShuKTtcbn1cblxudmFyIHBfX25hbWVzcGFjZSA9IC8qI19fUFVSRV9fKi9faW50ZXJvcE5hbWVzcGFjZShwKTtcblxudmFyIGFzdCA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGxcbn0pO1xuXG5jb25zdCBsZXggPSBsZWFjLmNyZWF0ZUxleGVyKFtcbiAgICB7IG5hbWU6ICd3cycsIHJlZ2V4OiAvWyBcXHRcXHJcXG5cXGZdKy8gfSxcbiAgICB7IG5hbWU6ICdpZG4nLCByZWdleDogL1thLXpBLVpfLV1bYS16QS1aMC05Xy1dKi8gfSxcbiAgICB7IG5hbWU6ICcjaWQnLCByZWdleDogLyNbYS16QS1aMC05Xy1dKy8gfSxcbiAgICB7IG5hbWU6ICdzdHIxJywgcmVnZXg6IC8nKD86XFxcXFsnXFxcXF18W15cXG4nXFxcXF0pKicvIH0sXG4gICAgeyBuYW1lOiAnc3RyMicsIHJlZ2V4OiAvXCIoPzpcXFxcW1wiXFxcXF18W15cXG5cIlxcXFxdKSpcIi8gfSxcbiAgICB7IG5hbWU6ICcqJyB9LFxuICAgIHsgbmFtZTogJy4nIH0sXG4gICAgeyBuYW1lOiAnLCcgfSxcbiAgICB7IG5hbWU6ICdbJyB9LFxuICAgIHsgbmFtZTogJ10nIH0sXG4gICAgeyBuYW1lOiAnPScgfSxcbiAgICB7IG5hbWU6ICc+JyB9LFxuICAgIHsgbmFtZTogJ3wnIH0sXG4gICAgeyBuYW1lOiAnKycgfSxcbiAgICB7IG5hbWU6ICd+JyB9LFxuICAgIHsgbmFtZTogJ14nIH0sXG4gICAgeyBuYW1lOiAnJCcgfSxcbl0pO1xuZnVuY3Rpb24gc3VtU3BlYyhbYTAsIGExLCBhMl0sIFtiMCwgYjEsIGIyXSkge1xuICAgIHJldHVybiBbYTAgKyBiMCwgYTEgKyBiMSwgYTIgKyBiMl07XG59XG5mdW5jdGlvbiBzdW1BbGxTcGVjKHNzKSB7XG4gICAgcmV0dXJuIHNzLnJlZHVjZShzdW1TcGVjLCBbMCwgMCwgMF0pO1xufVxuZnVuY3Rpb24gbGl0ZXJhbChuYW1lKSB7XG4gICAgcmV0dXJuIHBfX25hbWVzcGFjZS50b2tlbigodCkgPT4gdC5uYW1lID09PSBuYW1lID8gdHJ1ZSA6IHVuZGVmaW5lZCk7XG59XG5jb25zdCB3aGl0ZXNwYWNlXyA9IHBfX25hbWVzcGFjZS50b2tlbigodCkgPT4gdC5uYW1lID09PSAnd3MnID8gbnVsbCA6IHVuZGVmaW5lZCk7XG5jb25zdCBvcHRpb25hbFdoaXRlc3BhY2VfID0gcF9fbmFtZXNwYWNlLm9wdGlvbih3aGl0ZXNwYWNlXywgbnVsbCk7XG5mdW5jdGlvbiBvcHRpb25hbGx5U3BhY2VkKHBhcnNlcikge1xuICAgIHJldHVybiBwX19uYW1lc3BhY2UubWlkZGxlKG9wdGlvbmFsV2hpdGVzcGFjZV8sIHBhcnNlciwgb3B0aW9uYWxXaGl0ZXNwYWNlXyk7XG59XG5jb25zdCBpZGVudGlmaWVyXyA9IHBfX25hbWVzcGFjZS50b2tlbigodCkgPT4gdC5uYW1lID09PSAnaWRuJyA/IHQudGV4dCA6IHVuZGVmaW5lZCk7XG5jb25zdCBoYXNoSWRfID0gcF9fbmFtZXNwYWNlLnRva2VuKCh0KSA9PiB0Lm5hbWUgPT09ICcjaWQnID8gdC50ZXh0LnNsaWNlKDEpIDogdW5kZWZpbmVkKTtcbmNvbnN0IHN0cmluZ18gPSBwX19uYW1lc3BhY2UudG9rZW4oKHQpID0+IHQubmFtZS5zdGFydHNXaXRoKCdzdHInKSA/IHQudGV4dC5zbGljZSgxLCAtMSkgOiB1bmRlZmluZWQpO1xuY29uc3QgbmFtZXNwYWNlXyA9IHBfX25hbWVzcGFjZS5sZWZ0KHBfX25hbWVzcGFjZS5vcHRpb24oaWRlbnRpZmllcl8sICcnKSwgbGl0ZXJhbCgnfCcpKTtcbmNvbnN0IHF1YWxpZmllZE5hbWVfID0gcF9fbmFtZXNwYWNlLmVpdGhlck9yKHBfX25hbWVzcGFjZS5hYihuYW1lc3BhY2VfLCBpZGVudGlmaWVyXywgKG5zLCBuYW1lKSA9PiAoeyBuYW1lOiBuYW1lLCBuYW1lc3BhY2U6IG5zIH0pKSwgcF9fbmFtZXNwYWNlLm1hcChpZGVudGlmaWVyXywgKG5hbWUpID0+ICh7IG5hbWU6IG5hbWUsIG5hbWVzcGFjZTogbnVsbCB9KSkpO1xuY29uc3QgdW5pU2VsZWN0b3JfID0gcF9fbmFtZXNwYWNlLmVpdGhlck9yKHBfX25hbWVzcGFjZS5hYihuYW1lc3BhY2VfLCBsaXRlcmFsKCcqJyksIChucykgPT4gKHsgdHlwZTogJ3VuaXZlcnNhbCcsIG5hbWVzcGFjZTogbnMsIHNwZWNpZmljaXR5OiBbMCwgMCwgMF0gfSkpLCBwX19uYW1lc3BhY2UubWFwKGxpdGVyYWwoJyonKSwgKCkgPT4gKHsgdHlwZTogJ3VuaXZlcnNhbCcsIG5hbWVzcGFjZTogbnVsbCwgc3BlY2lmaWNpdHk6IFswLCAwLCAwXSB9KSkpO1xuY29uc3QgdGFnU2VsZWN0b3JfID0gcF9fbmFtZXNwYWNlLm1hcChxdWFsaWZpZWROYW1lXywgKHsgbmFtZSwgbmFtZXNwYWNlIH0pID0+ICh7XG4gICAgdHlwZTogJ3RhZycsXG4gICAgbmFtZTogbmFtZSxcbiAgICBuYW1lc3BhY2U6IG5hbWVzcGFjZSxcbiAgICBzcGVjaWZpY2l0eTogWzAsIDAsIDFdXG59KSk7XG5jb25zdCBjbGFzc1NlbGVjdG9yXyA9IHBfX25hbWVzcGFjZS5hYihsaXRlcmFsKCcuJyksIGlkZW50aWZpZXJfLCAoZnVsbHN0b3AsIG5hbWUpID0+ICh7XG4gICAgdHlwZTogJ2NsYXNzJyxcbiAgICBuYW1lOiBuYW1lLFxuICAgIHNwZWNpZmljaXR5OiBbMCwgMSwgMF1cbn0pKTtcbmNvbnN0IGlkU2VsZWN0b3JfID0gcF9fbmFtZXNwYWNlLm1hcChoYXNoSWRfLCAobmFtZSkgPT4gKHtcbiAgICB0eXBlOiAnaWQnLFxuICAgIG5hbWU6IG5hbWUsXG4gICAgc3BlY2lmaWNpdHk6IFsxLCAwLCAwXVxufSkpO1xuY29uc3QgYXR0ck1vZGlmaWVyXyA9IHBfX25hbWVzcGFjZS50b2tlbigodCkgPT4ge1xuICAgIGlmICh0Lm5hbWUgPT09ICdpZG4nKSB7XG4gICAgICAgIGlmICh0LnRleHQgPT09ICdpJyB8fCB0LnRleHQgPT09ICdJJykge1xuICAgICAgICAgICAgcmV0dXJuICdpJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodC50ZXh0ID09PSAncycgfHwgdC50ZXh0ID09PSAnUycpIHtcbiAgICAgICAgICAgIHJldHVybiAncyc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn0pO1xuY29uc3QgYXR0clZhbHVlXyA9IHBfX25hbWVzcGFjZS5laXRoZXJPcihwX19uYW1lc3BhY2UuYWIoc3RyaW5nXywgcF9fbmFtZXNwYWNlLm9wdGlvbihwX19uYW1lc3BhY2UucmlnaHQob3B0aW9uYWxXaGl0ZXNwYWNlXywgYXR0ck1vZGlmaWVyXyksIG51bGwpLCAodiwgbW9kKSA9PiAoeyB2YWx1ZTogdiwgbW9kaWZpZXI6IG1vZCB9KSksIHBfX25hbWVzcGFjZS5hYihpZGVudGlmaWVyXywgcF9fbmFtZXNwYWNlLm9wdGlvbihwX19uYW1lc3BhY2UucmlnaHQod2hpdGVzcGFjZV8sIGF0dHJNb2RpZmllcl8pLCBudWxsKSwgKHYsIG1vZCkgPT4gKHsgdmFsdWU6IHYsIG1vZGlmaWVyOiBtb2QgfSkpKTtcbmNvbnN0IGF0dHJNYXRjaGVyXyA9IHBfX25hbWVzcGFjZS5jaG9pY2UocF9fbmFtZXNwYWNlLm1hcChsaXRlcmFsKCc9JyksICgpID0+ICc9JyksIHBfX25hbWVzcGFjZS5hYihsaXRlcmFsKCd+JyksIGxpdGVyYWwoJz0nKSwgKCkgPT4gJ349JyksIHBfX25hbWVzcGFjZS5hYihsaXRlcmFsKCd8JyksIGxpdGVyYWwoJz0nKSwgKCkgPT4gJ3w9JyksIHBfX25hbWVzcGFjZS5hYihsaXRlcmFsKCdeJyksIGxpdGVyYWwoJz0nKSwgKCkgPT4gJ149JyksIHBfX25hbWVzcGFjZS5hYihsaXRlcmFsKCckJyksIGxpdGVyYWwoJz0nKSwgKCkgPT4gJyQ9JyksIHBfX25hbWVzcGFjZS5hYihsaXRlcmFsKCcqJyksIGxpdGVyYWwoJz0nKSwgKCkgPT4gJyo9JykpO1xuY29uc3QgYXR0clByZXNlbmNlU2VsZWN0b3JfID0gcF9fbmFtZXNwYWNlLmFiYyhsaXRlcmFsKCdbJyksIG9wdGlvbmFsbHlTcGFjZWQocXVhbGlmaWVkTmFtZV8pLCBsaXRlcmFsKCddJyksIChsYnIsIHsgbmFtZSwgbmFtZXNwYWNlIH0pID0+ICh7XG4gICAgdHlwZTogJ2F0dHJQcmVzZW5jZScsXG4gICAgbmFtZTogbmFtZSxcbiAgICBuYW1lc3BhY2U6IG5hbWVzcGFjZSxcbiAgICBzcGVjaWZpY2l0eTogWzAsIDEsIDBdXG59KSk7XG5jb25zdCBhdHRyVmFsdWVTZWxlY3Rvcl8gPSBwX19uYW1lc3BhY2UubWlkZGxlKGxpdGVyYWwoJ1snKSwgcF9fbmFtZXNwYWNlLmFiYyhvcHRpb25hbGx5U3BhY2VkKHF1YWxpZmllZE5hbWVfKSwgYXR0ck1hdGNoZXJfLCBvcHRpb25hbGx5U3BhY2VkKGF0dHJWYWx1ZV8pLCAoeyBuYW1lLCBuYW1lc3BhY2UgfSwgbWF0Y2hlciwgeyB2YWx1ZSwgbW9kaWZpZXIgfSkgPT4gKHtcbiAgICB0eXBlOiAnYXR0clZhbHVlJyxcbiAgICBuYW1lOiBuYW1lLFxuICAgIG5hbWVzcGFjZTogbmFtZXNwYWNlLFxuICAgIG1hdGNoZXI6IG1hdGNoZXIsXG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIG1vZGlmaWVyOiBtb2RpZmllcixcbiAgICBzcGVjaWZpY2l0eTogWzAsIDEsIDBdXG59KSksIGxpdGVyYWwoJ10nKSk7XG5jb25zdCBhdHRyU2VsZWN0b3JfID0gcF9fbmFtZXNwYWNlLmVpdGhlck9yKGF0dHJQcmVzZW5jZVNlbGVjdG9yXywgYXR0clZhbHVlU2VsZWN0b3JfKTtcbmNvbnN0IHR5cGVTZWxlY3Rvcl8gPSBwX19uYW1lc3BhY2UuZWl0aGVyT3IodW5pU2VsZWN0b3JfLCB0YWdTZWxlY3Rvcl8pO1xuY29uc3Qgc3ViY2xhc3NTZWxlY3Rvcl8gPSBwX19uYW1lc3BhY2UuY2hvaWNlKGlkU2VsZWN0b3JfLCBjbGFzc1NlbGVjdG9yXywgYXR0clNlbGVjdG9yXyk7XG5jb25zdCBjb21wb3VuZFNlbGVjdG9yXyA9IHBfX25hbWVzcGFjZS5tYXAocF9fbmFtZXNwYWNlLmVpdGhlck9yKHBfX25hbWVzcGFjZS5mbGF0dGVuKHR5cGVTZWxlY3Rvcl8sIHBfX25hbWVzcGFjZS5tYW55KHN1YmNsYXNzU2VsZWN0b3JfKSksIHBfX25hbWVzcGFjZS5tYW55MShzdWJjbGFzc1NlbGVjdG9yXykpLCAoc3MpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnY29tcG91bmQnLFxuICAgICAgICBsaXN0OiBzcyxcbiAgICAgICAgc3BlY2lmaWNpdHk6IHN1bUFsbFNwZWMoc3MubWFwKHMgPT4gcy5zcGVjaWZpY2l0eSkpXG4gICAgfTtcbn0pO1xuY29uc3QgY29tYmluYXRvcl8gPSBwX19uYW1lc3BhY2UuY2hvaWNlKHBfX25hbWVzcGFjZS5tYXAobGl0ZXJhbCgnPicpLCAoKSA9PiAnPicpLCBwX19uYW1lc3BhY2UubWFwKGxpdGVyYWwoJysnKSwgKCkgPT4gJysnKSwgcF9fbmFtZXNwYWNlLm1hcChsaXRlcmFsKCd+JyksICgpID0+ICd+JyksIHBfX25hbWVzcGFjZS5hYihsaXRlcmFsKCd8JyksIGxpdGVyYWwoJ3wnKSwgKCkgPT4gJ3x8JykpO1xuY29uc3QgY29tYmluYXRvclNlcGFyYXRvcl8gPSBwX19uYW1lc3BhY2UuZWl0aGVyT3Iob3B0aW9uYWxseVNwYWNlZChjb21iaW5hdG9yXyksIHBfX25hbWVzcGFjZS5tYXAod2hpdGVzcGFjZV8sICgpID0+ICcgJykpO1xuY29uc3QgY29tcGxleFNlbGVjdG9yXyA9IHBfX25hbWVzcGFjZS5sZWZ0QXNzb2MyKGNvbXBvdW5kU2VsZWN0b3JfLCBwX19uYW1lc3BhY2UubWFwKGNvbWJpbmF0b3JTZXBhcmF0b3JfLCAoYykgPT4gKGxlZnQsIHJpZ2h0KSA9PiAoe1xuICAgIHR5cGU6ICdjb21wb3VuZCcsXG4gICAgbGlzdDogWy4uLnJpZ2h0Lmxpc3QsIHsgdHlwZTogJ2NvbWJpbmF0b3InLCBjb21iaW5hdG9yOiBjLCBsZWZ0OiBsZWZ0LCBzcGVjaWZpY2l0eTogbGVmdC5zcGVjaWZpY2l0eSB9XSxcbiAgICBzcGVjaWZpY2l0eTogc3VtU3BlYyhsZWZ0LnNwZWNpZmljaXR5LCByaWdodC5zcGVjaWZpY2l0eSlcbn0pKSwgY29tcG91bmRTZWxlY3Rvcl8pO1xuY29uc3QgbGlzdFNlbGVjdG9yXyA9IHBfX25hbWVzcGFjZS5sZWZ0QXNzb2MyKHBfX25hbWVzcGFjZS5tYXAoY29tcGxleFNlbGVjdG9yXywgKHMpID0+ICh7IHR5cGU6ICdsaXN0JywgbGlzdDogW3NdIH0pKSwgcF9fbmFtZXNwYWNlLm1hcChvcHRpb25hbGx5U3BhY2VkKGxpdGVyYWwoJywnKSksICgpID0+IChhY2MsIG5leHQpID0+ICh7IHR5cGU6ICdsaXN0JywgbGlzdDogWy4uLmFjYy5saXN0LCBuZXh0XSB9KSksIGNvbXBsZXhTZWxlY3Rvcl8pO1xuZnVuY3Rpb24gcGFyc2VfKHBhcnNlciwgc3RyKSB7XG4gICAgY29uc3QgbGV4ZXJSZXN1bHQgPSBsZXgoc3RyKTtcbiAgICBpZiAoIWxleGVyUmVzdWx0LmNvbXBsZXRlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGlucHV0IFwiJHtzdHJ9XCIgd2FzIG9ubHkgcGFydGlhbGx5IHRva2VuaXplZCwgc3RvcHBlZCBhdCBvZmZzZXQgJHtsZXhlclJlc3VsdC5vZmZzZXR9IVxcbmAgK1xuICAgICAgICAgICAgcHJldHR5UHJpbnRQb3NpdGlvbihzdHIsIGxleGVyUmVzdWx0Lm9mZnNldCkpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBvcHRpb25hbGx5U3BhY2VkKHBhcnNlcikoeyB0b2tlbnM6IGxleGVyUmVzdWx0LnRva2Vucywgb3B0aW9uczogdW5kZWZpbmVkIH0sIDApO1xuICAgIGlmICghcmVzdWx0Lm1hdGNoZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBtYXRjaCBmb3IgXCIke3N0cn1cIiBpbnB1dCFgKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5wb3NpdGlvbiA8IGxleGVyUmVzdWx0LnRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgdG9rZW4gPSBsZXhlclJlc3VsdC50b2tlbnNbcmVzdWx0LnBvc2l0aW9uXTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgaW5wdXQgXCIke3N0cn1cIiB3YXMgb25seSBwYXJ0aWFsbHkgcGFyc2VkLCBzdG9wcGVkIGF0IG9mZnNldCAke3Rva2VuLm9mZnNldH0hXFxuYCArXG4gICAgICAgICAgICBwcmV0dHlQcmludFBvc2l0aW9uKHN0ciwgdG9rZW4ub2Zmc2V0LCB0b2tlbi5sZW4pKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbn1cbmZ1bmN0aW9uIHByZXR0eVByaW50UG9zaXRpb24oc3RyLCBvZmZzZXQsIGxlbiA9IDEpIHtcbiAgICByZXR1cm4gYCR7c3RyLnJlcGxhY2UoLyhcXHQpfChcXHIpfChcXG4pL2csIChtLCB0LCByKSA9PiB0ID8gJ1xcdTI0MDknIDogciA/ICdcXHUyNDBkJyA6ICdcXHUyNDBhJyl9XFxuJHsnJy5wYWRFbmQob2Zmc2V0KX0keydeJy5yZXBlYXQobGVuKX1gO1xufVxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gICAgcmV0dXJuIHBhcnNlXyhsaXN0U2VsZWN0b3JfLCBzdHIpO1xufVxuZnVuY3Rpb24gcGFyc2UxKHN0cikge1xuICAgIHJldHVybiBwYXJzZV8oY29tcGxleFNlbGVjdG9yXywgc3RyKTtcbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplKHNlbGVjdG9yKSB7XG4gICAgaWYgKCFzZWxlY3Rvci50eXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBpcyBub3QgYW4gQVNUIG5vZGUuJyk7XG4gICAgfVxuICAgIHN3aXRjaCAoc2VsZWN0b3IudHlwZSkge1xuICAgICAgICBjYXNlICd1bml2ZXJzYWwnOlxuICAgICAgICAgICAgcmV0dXJuIF9zZXJOcyhzZWxlY3Rvci5uYW1lc3BhY2UpICsgJyonO1xuICAgICAgICBjYXNlICd0YWcnOlxuICAgICAgICAgICAgcmV0dXJuIF9zZXJOcyhzZWxlY3Rvci5uYW1lc3BhY2UpICsgc2VsZWN0b3IubmFtZTtcbiAgICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgICAgICAgcmV0dXJuICcuJyArIHNlbGVjdG9yLm5hbWU7XG4gICAgICAgIGNhc2UgJ2lkJzpcbiAgICAgICAgICAgIHJldHVybiAnIycgKyBzZWxlY3Rvci5uYW1lO1xuICAgICAgICBjYXNlICdhdHRyUHJlc2VuY2UnOlxuICAgICAgICAgICAgcmV0dXJuIGBbJHtfc2VyTnMoc2VsZWN0b3IubmFtZXNwYWNlKX0ke3NlbGVjdG9yLm5hbWV9XWA7XG4gICAgICAgIGNhc2UgJ2F0dHJWYWx1ZSc6XG4gICAgICAgICAgICByZXR1cm4gYFske19zZXJOcyhzZWxlY3Rvci5uYW1lc3BhY2UpfSR7c2VsZWN0b3IubmFtZX0ke3NlbGVjdG9yLm1hdGNoZXJ9JHtfc2VyU3RyKHNlbGVjdG9yLnZhbHVlKX0keyhzZWxlY3Rvci5tb2RpZmllciA/IHNlbGVjdG9yLm1vZGlmaWVyIDogJycpfV1gO1xuICAgICAgICBjYXNlICdjb21iaW5hdG9yJzpcbiAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemUoc2VsZWN0b3IubGVmdCkgKyBzZWxlY3Rvci5jb21iaW5hdG9yO1xuICAgICAgICBjYXNlICdjb21wb3VuZCc6XG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0b3IubGlzdC5yZWR1Y2UoKGFjYywgbm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdjb21iaW5hdG9yJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplKG5vZGUpICsgYWNjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjYyArIHNlcmlhbGl6ZShub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAnJyk7XG4gICAgICAgIGNhc2UgJ2xpc3QnOlxuICAgICAgICAgICAgcmV0dXJuIHNlbGVjdG9yLmxpc3QubWFwKHNlcmlhbGl6ZSkuam9pbignLCcpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9zZXJOcyhucykge1xuICAgIHJldHVybiAobnMgfHwgbnMgPT09ICcnKVxuICAgICAgICA/IG5zICsgJ3wnXG4gICAgICAgIDogJyc7XG59XG5mdW5jdGlvbiBfc2VyU3RyKHN0cikge1xuICAgIGlmIChzdHIuaW5kZXhPZignXCInKSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIGBcIiR7c3RyfVwiYDtcbiAgICB9XG4gICAgZWxzZSBpZiAoc3RyLmluZGV4T2YoXCInXCIpID09PSAtMSkge1xuICAgICAgICByZXR1cm4gYCcke3N0cn0nYDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBgXCIke3N0ci5yZXBsYWNlKCdcIicsICdcXFxcXCInKX1cImA7XG4gICAgfVxufVxuZnVuY3Rpb24gbm9ybWFsaXplKHNlbGVjdG9yKSB7XG4gICAgaWYgKCFzZWxlY3Rvci50eXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBpcyBub3QgYW4gQVNUIG5vZGUuJyk7XG4gICAgfVxuICAgIHN3aXRjaCAoc2VsZWN0b3IudHlwZSkge1xuICAgICAgICBjYXNlICdjb21wb3VuZCc6IHtcbiAgICAgICAgICAgIHNlbGVjdG9yLmxpc3QuZm9yRWFjaChub3JtYWxpemUpO1xuICAgICAgICAgICAgc2VsZWN0b3IubGlzdC5zb3J0KChhLCBiKSA9PiBfY29tcGFyZUFycmF5cyhfZ2V0U2VsZWN0b3JQcmlvcml0eShhKSwgX2dldFNlbGVjdG9yUHJpb3JpdHkoYikpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2NvbWJpbmF0b3InOiB7XG4gICAgICAgICAgICBub3JtYWxpemUoc2VsZWN0b3IubGVmdCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdsaXN0Jzoge1xuICAgICAgICAgICAgc2VsZWN0b3IubGlzdC5mb3JFYWNoKG5vcm1hbGl6ZSk7XG4gICAgICAgICAgICBzZWxlY3Rvci5saXN0LnNvcnQoKGEsIGIpID0+IChzZXJpYWxpemUoYSkgPCBzZXJpYWxpemUoYikpID8gLTEgOiAxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZWxlY3Rvcjtcbn1cbmZ1bmN0aW9uIF9nZXRTZWxlY3RvclByaW9yaXR5KHNlbGVjdG9yKSB7XG4gICAgc3dpdGNoIChzZWxlY3Rvci50eXBlKSB7XG4gICAgICAgIGNhc2UgJ3VuaXZlcnNhbCc6XG4gICAgICAgICAgICByZXR1cm4gWzFdO1xuICAgICAgICBjYXNlICd0YWcnOlxuICAgICAgICAgICAgcmV0dXJuIFsxXTtcbiAgICAgICAgY2FzZSAnaWQnOlxuICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgICAgICAgcmV0dXJuIFszLCBzZWxlY3Rvci5uYW1lXTtcbiAgICAgICAgY2FzZSAnYXR0clByZXNlbmNlJzpcbiAgICAgICAgICAgIHJldHVybiBbNCwgc2VyaWFsaXplKHNlbGVjdG9yKV07XG4gICAgICAgIGNhc2UgJ2F0dHJWYWx1ZSc6XG4gICAgICAgICAgICByZXR1cm4gWzUsIHNlcmlhbGl6ZShzZWxlY3RvcildO1xuICAgICAgICBjYXNlICdjb21iaW5hdG9yJzpcbiAgICAgICAgICAgIHJldHVybiBbMTUsIHNlcmlhbGl6ZShzZWxlY3RvcildO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbXBhcmVTZWxlY3RvcnMoYSwgYikge1xuICAgIHJldHVybiBfY29tcGFyZUFycmF5cyhhLnNwZWNpZmljaXR5LCBiLnNwZWNpZmljaXR5KTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVTcGVjaWZpY2l0eShhLCBiKSB7XG4gICAgcmV0dXJuIF9jb21wYXJlQXJyYXlzKGEsIGIpO1xufVxuZnVuY3Rpb24gX2NvbXBhcmVBcnJheXMoYSwgYikge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhKSB8fCAhQXJyYXkuaXNBcnJheShiKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIGFycmF5cy4nKTtcbiAgICB9XG4gICAgY29uc3Qgc2hvcnRlciA9IChhLmxlbmd0aCA8IGIubGVuZ3RoKSA/IGEubGVuZ3RoIDogYi5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaG9ydGVyOyBpKyspIHtcbiAgICAgICAgaWYgKGFbaV0gPT09IGJbaV0pIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoYVtpXSA8IGJbaV0pID8gLTEgOiAxO1xuICAgIH1cbiAgICByZXR1cm4gYS5sZW5ndGggLSBiLmxlbmd0aDtcbn1cblxuZXhwb3J0cy5Bc3QgPSBhc3Q7XG5leHBvcnRzLmNvbXBhcmVTZWxlY3RvcnMgPSBjb21wYXJlU2VsZWN0b3JzO1xuZXhwb3J0cy5jb21wYXJlU3BlY2lmaWNpdHkgPSBjb21wYXJlU3BlY2lmaWNpdHk7XG5leHBvcnRzLm5vcm1hbGl6ZSA9IG5vcm1hbGl6ZTtcbmV4cG9ydHMucGFyc2UgPSBwYXJzZTtcbmV4cG9ydHMucGFyc2UxID0gcGFyc2UxO1xuZXhwb3J0cy5zZXJpYWxpemUgPSBzZXJpYWxpemU7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJsZWFjIiwicmVxdWlyZSIsInAiLCJfaW50ZXJvcE5hbWVzcGFjZSIsImUiLCJfX2VzTW9kdWxlIiwibiIsImNyZWF0ZSIsImtleXMiLCJmb3JFYWNoIiwiayIsImQiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJnZXQiLCJlbnVtZXJhYmxlIiwiZnJlZXplIiwicF9fbmFtZXNwYWNlIiwiYXN0IiwiX19wcm90b19fIiwibGV4IiwiY3JlYXRlTGV4ZXIiLCJuYW1lIiwicmVnZXgiLCJzdW1TcGVjIiwiYTAiLCJhMSIsImEyIiwiYjAiLCJiMSIsImIyIiwic3VtQWxsU3BlYyIsInNzIiwicmVkdWNlIiwibGl0ZXJhbCIsInRva2VuIiwidCIsInVuZGVmaW5lZCIsIndoaXRlc3BhY2VfIiwib3B0aW9uYWxXaGl0ZXNwYWNlXyIsIm9wdGlvbiIsIm9wdGlvbmFsbHlTcGFjZWQiLCJwYXJzZXIiLCJtaWRkbGUiLCJpZGVudGlmaWVyXyIsInRleHQiLCJoYXNoSWRfIiwic2xpY2UiLCJzdHJpbmdfIiwic3RhcnRzV2l0aCIsIm5hbWVzcGFjZV8iLCJsZWZ0IiwicXVhbGlmaWVkTmFtZV8iLCJlaXRoZXJPciIsImFiIiwibnMiLCJuYW1lc3BhY2UiLCJtYXAiLCJ1bmlTZWxlY3Rvcl8iLCJ0eXBlIiwic3BlY2lmaWNpdHkiLCJ0YWdTZWxlY3Rvcl8iLCJjbGFzc1NlbGVjdG9yXyIsImZ1bGxzdG9wIiwiaWRTZWxlY3Rvcl8iLCJhdHRyTW9kaWZpZXJfIiwiYXR0clZhbHVlXyIsInJpZ2h0IiwidiIsIm1vZCIsIm1vZGlmaWVyIiwiYXR0ck1hdGNoZXJfIiwiY2hvaWNlIiwiYXR0clByZXNlbmNlU2VsZWN0b3JfIiwiYWJjIiwibGJyIiwiYXR0clZhbHVlU2VsZWN0b3JfIiwibWF0Y2hlciIsImF0dHJTZWxlY3Rvcl8iLCJ0eXBlU2VsZWN0b3JfIiwic3ViY2xhc3NTZWxlY3Rvcl8iLCJjb21wb3VuZFNlbGVjdG9yXyIsImZsYXR0ZW4iLCJtYW55IiwibWFueTEiLCJsaXN0IiwicyIsImNvbWJpbmF0b3JfIiwiY29tYmluYXRvclNlcGFyYXRvcl8iLCJjb21wbGV4U2VsZWN0b3JfIiwibGVmdEFzc29jMiIsImMiLCJjb21iaW5hdG9yIiwibGlzdFNlbGVjdG9yXyIsImFjYyIsIm5leHQiLCJwYXJzZV8iLCJzdHIiLCJsZXhlclJlc3VsdCIsImNvbXBsZXRlIiwiRXJyb3IiLCJvZmZzZXQiLCJwcmV0dHlQcmludFBvc2l0aW9uIiwicmVzdWx0IiwidG9rZW5zIiwib3B0aW9ucyIsIm1hdGNoZWQiLCJwb3NpdGlvbiIsImxlbmd0aCIsImxlbiIsInJlcGxhY2UiLCJtIiwiciIsInBhZEVuZCIsInJlcGVhdCIsInBhcnNlIiwicGFyc2UxIiwic2VyaWFsaXplIiwic2VsZWN0b3IiLCJfc2VyTnMiLCJfc2VyU3RyIiwibm9kZSIsImpvaW4iLCJpbmRleE9mIiwibm9ybWFsaXplIiwic29ydCIsImEiLCJiIiwiX2NvbXBhcmVBcnJheXMiLCJfZ2V0U2VsZWN0b3JQcmlvcml0eSIsImNvbXBhcmVTZWxlY3RvcnMiLCJjb21wYXJlU3BlY2lmaWNpdHkiLCJBcnJheSIsImlzQXJyYXkiLCJzaG9ydGVyIiwiaSIsIkFzdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/parseley/lib/parseley.cjs\n");

/***/ })

};
;